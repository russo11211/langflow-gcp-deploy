{
  "data": {
    "edges": [
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "Agent",
            "id": "Agent-Oloh8",
            "name": "response",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "ChatOutput-ggq1G",
            "inputTypes": [
              "Data",
              "DataFrame",
              "Message"
            ],
            "type": "other"
          }
        },
        "id": "reactflow__edge-Agent-Oloh8{Å“dataTypeÅ“:Å“AgentÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“nameÅ“:Å“responseÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}-ChatOutput-ggq1G{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“ChatOutput-ggq1GÅ“,Å“inputTypesÅ“:[Å“DataÅ“,Å“DataFrameÅ“,Å“MessageÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "Agent-Oloh8",
        "sourceHandle": "{Å“dataTypeÅ“:Å“AgentÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“nameÅ“:Å“responseÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}",
        "target": "ChatOutput-ggq1G",
        "targetHandle": "{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“ChatOutput-ggq1GÅ“,Å“inputTypesÅ“:[Å“DataÅ“,Å“DataFrameÅ“,Å“MessageÅ“],Å“typeÅ“:Å“otherÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ChatInput",
            "id": "ChatInput-mTUKt",
            "name": "message",
            "output_types": [
              "Message"
            ]
          },
          "targetHandle": {
            "fieldName": "input_value",
            "id": "Agent-Oloh8",
            "inputTypes": [
              "Message"
            ],
            "type": "str"
          }
        },
        "id": "reactflow__edge-ChatInput-mTUKt{Å“dataTypeÅ“:Å“ChatInputÅ“,Å“idÅ“:Å“ChatInput-mTUKtÅ“,Å“nameÅ“:Å“messageÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}-Agent-Oloh8{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“MessageÅ“],Å“typeÅ“:Å“strÅ“}",
        "selected": false,
        "source": "ChatInput-mTUKt",
        "sourceHandle": "{Å“dataTypeÅ“:Å“ChatInputÅ“,Å“idÅ“:Å“ChatInput-mTUKtÅ“,Å“nameÅ“:Å“messageÅ“,Å“output_typesÅ“:[Å“MessageÅ“]}",
        "target": "Agent-Oloh8",
        "targetHandle": "{Å“fieldNameÅ“:Å“input_valueÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“MessageÅ“],Å“typeÅ“:Å“strÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "FileManipulation",
            "id": "FileManipulation-Z3xCV",
            "name": "tools",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-Oloh8",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__FileManipulation-Z3xCV{Å“dataTypeÅ“:Å“FileManipulationÅ“,Å“idÅ“:Å“FileManipulation-Z3xCVÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}-Agent-Oloh8{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "FileManipulation-Z3xCV",
        "sourceHandle": "{Å“dataTypeÅ“:Å“FileManipulationÅ“,Å“idÅ“:Å“FileManipulation-Z3xCVÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}",
        "target": "Agent-Oloh8",
        "targetHandle": "{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "ShellSessionManager",
            "id": "ShellSessionManager-lNmvb",
            "name": "tools",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-Oloh8",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__ShellSessionManager-lNmvb{Å“dataTypeÅ“:Å“ShellSessionManagerÅ“,Å“idÅ“:Å“ShellSessionManager-lNmvbÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}-Agent-Oloh8{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "ShellSessionManager-lNmvb",
        "sourceHandle": "{Å“dataTypeÅ“:Å“ShellSessionManagerÅ“,Å“idÅ“:Å“ShellSessionManager-lNmvbÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}",
        "target": "Agent-Oloh8",
        "targetHandle": "{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}"
      },
      {
        "animated": false,
        "className": "",
        "data": {
          "sourceHandle": {
            "dataType": "GitOperations",
            "id": "CustomComponent-tDs9a",
            "name": "tools",
            "output_types": [
              "Tool"
            ]
          },
          "targetHandle": {
            "fieldName": "tools",
            "id": "Agent-Oloh8",
            "inputTypes": [
              "Tool"
            ],
            "type": "other"
          }
        },
        "id": "xy-edge__CustomComponent-tDs9a{Å“dataTypeÅ“:Å“GitOperationsÅ“,Å“idÅ“:Å“CustomComponent-tDs9aÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}-Agent-Oloh8{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}",
        "selected": false,
        "source": "CustomComponent-tDs9a",
        "sourceHandle": "{Å“dataTypeÅ“:Å“GitOperationsÅ“,Å“idÅ“:Å“CustomComponent-tDs9aÅ“,Å“nameÅ“:Å“toolsÅ“,Å“output_typesÅ“:[Å“ToolÅ“]}",
        "target": "Agent-Oloh8",
        "targetHandle": "{Å“fieldNameÅ“:Å“toolsÅ“,Å“idÅ“:Å“Agent-Oloh8Å“,Å“inputTypesÅ“:[Å“ToolÅ“],Å“typeÅ“:Å“otherÅ“}"
      }
    ],
    "nodes": [
      {
        "data": {
          "id": "note-4P3TA",
          "node": {
            "description": "# ðŸ“– README  \nMeet the **Component Maker Agent**: your expert assistant for creating and modifying custom components in Langflow.\n\nThe Component Maker Agent helps you design, implement, and test new Langflow components or update existing ones. It guides you through requirements gathering, codebase exploration, implementation, and robust testingâ€”ensuring your components are high-quality and production-ready.\n\n## Quick start\n\n1. Tell the Component Maker Agent what kind of component you want to create or modify.  \n   (Describe its purpose, inputs, outputs, and any special requirements.)\n2. The Agent will ask clarifying questions if needed, then set up a feature branch and explore your codebase.\n3. The Agent will generate the component code, place it in the correct directory, and create comprehensive tests.\n4. The Agent will run tests, fix any issues, and ensure everything works before finishing.\n5. Review the results, and your new or updated component is ready to use in Langflow!\n\n## Next steps\n\n- Use the Agent to add more advanced features, connect external APIs, or automate repetitive component development tasks.\n- Ask the Agent to update or refactor existing components for better performance or new capabilities.\n- Let the Agent help you maintain high code quality and test coverage across your Langflow project.\n\nFor more, see the [Langflow docs](https://docs.langflow.org/agents-tool-calling-agent-component).\n\n---",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "neutral"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-4P3TA",
        "measured": {
          "height": 1263,
          "width": 324
        },
        "position": {
          "x": 592.7515419276402,
          "y": 247.0244405776931
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-VjOoG",
          "node": {
            "description": "### ðŸ’¡ Add your OpenAI API key hereðŸ‘‡",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "id": "note-VjOoG",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 1648.6876745095624,
          "y": 253.8646618156497
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "ChatInput-mTUKt",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "inputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Get chat inputs from the Playground.",
            "display_name": "Chat Input",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "files",
              "background_color",
              "chat_icon",
              "text_color"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatInput",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0020353564437605998,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langflow.base.data.utils import IMG_FILE_TYPES, TEXT_FILE_TYPES\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.io import (\n    DropdownInput,\n    FileInput,\n    MessageTextInput,\n    MultilineInput,\n    Output,\n)\nfrom langflow.schema.message import Message\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_USER,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatInput(ChatComponent):\n    display_name = \"Chat Input\"\n    description = \"Get chat inputs from the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatInput\"\n    minimized = True\n\n    inputs = [\n        MultilineInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            value=\"\",\n            info=\"Message to be passed as input.\",\n            input_types=[],\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_USER,\n            info=\"Type of sender.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_USER,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        FileInput(\n            name=\"files\",\n            display_name=\"Files\",\n            file_types=TEXT_FILE_TYPES + IMG_FILE_TYPES,\n            info=\"Files to be sent with the message.\",\n            advanced=True,\n            is_list=True,\n            temp_file=True,\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(display_name=\"Message\", name=\"message\", method=\"message_response\"),\n    ]\n\n    async def message_response(self) -> Message:\n        background_color = self.background_color\n        text_color = self.text_color\n        icon = self.chat_icon\n\n        message = await Message.create(\n            text=self.input_value,\n            sender=self.sender,\n            sender_name=self.sender_name,\n            session_id=self.session_id,\n            files=self.files,\n            properties={\n                \"background_color\": background_color,\n                \"text_color\": text_color,\n                \"icon\": icon,\n            },\n        )\n        if self.session_id and isinstance(message, Message) and self.should_store_message:\n            stored_message = await self.send_message(\n                message,\n            )\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n"
              },
              "files": {
                "_input_type": "FileInput",
                "advanced": true,
                "display_name": "Files",
                "dynamic": false,
                "fileTypes": [
                  "txt",
                  "md",
                  "mdx",
                  "csv",
                  "json",
                  "yaml",
                  "yml",
                  "xml",
                  "html",
                  "htm",
                  "pdf",
                  "docx",
                  "py",
                  "sh",
                  "sql",
                  "js",
                  "ts",
                  "tsx",
                  "jpg",
                  "jpeg",
                  "png",
                  "bmp",
                  "image"
                ],
                "file_path": "",
                "info": "Files to be sent with the message.",
                "list": true,
                "list_add_label": "Add More",
                "name": "files",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "file",
                "value": ""
              },
              "input_value": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as input.",
                "input_types": [],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "User"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatInput"
        },
        "dragging": false,
        "id": "ChatInput-mTUKt",
        "measured": {
          "height": 65,
          "width": 192
        },
        "position": {
          "x": 1398.8340213507608,
          "y": 1533.7925113328358
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ChatOutput-ggq1G",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "outputs",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Display a chat message in the Playground.",
            "display_name": "Chat Output",
            "documentation": "",
            "edited": false,
            "field_order": [
              "input_value",
              "should_store_message",
              "sender",
              "sender_name",
              "session_id",
              "data_template",
              "background_color",
              "chat_icon",
              "text_color",
              "clean_data"
            ],
            "frozen": false,
            "icon": "MessagesSquare",
            "key": "ChatOutput",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": true,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Message",
                "method": "message_response",
                "name": "message",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.003169567463043492,
            "template": {
              "_type": "Component",
              "background_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Background Color",
                "dynamic": false,
                "info": "The background color of the icon.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "background_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "chat_icon": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Icon",
                "dynamic": false,
                "info": "The icon of the message.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "chat_icon",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "clean_data": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Basic Clean Data",
                "dynamic": false,
                "info": "Whether to clean the data",
                "list": false,
                "list_add_label": "Add More",
                "name": "clean_data",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from collections.abc import Generator\nfrom typing import Any\n\nimport orjson\nfrom fastapi.encoders import jsonable_encoder\n\nfrom langflow.base.io.chat import ChatComponent\nfrom langflow.inputs import BoolInput\nfrom langflow.inputs.inputs import HandleInput\nfrom langflow.io import DropdownInput, MessageTextInput, Output\nfrom langflow.schema.data import Data\nfrom langflow.schema.dataframe import DataFrame\nfrom langflow.schema.message import Message\nfrom langflow.schema.properties import Source\nfrom langflow.utils.constants import (\n    MESSAGE_SENDER_AI,\n    MESSAGE_SENDER_NAME_AI,\n    MESSAGE_SENDER_USER,\n)\n\n\nclass ChatOutput(ChatComponent):\n    display_name = \"Chat Output\"\n    description = \"Display a chat message in the Playground.\"\n    icon = \"MessagesSquare\"\n    name = \"ChatOutput\"\n    minimized = True\n\n    inputs = [\n        HandleInput(\n            name=\"input_value\",\n            display_name=\"Text\",\n            info=\"Message to be passed as output.\",\n            input_types=[\"Data\", \"DataFrame\", \"Message\"],\n            required=True,\n        ),\n        BoolInput(\n            name=\"should_store_message\",\n            display_name=\"Store Messages\",\n            info=\"Store the message in the history.\",\n            value=True,\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"sender\",\n            display_name=\"Sender Type\",\n            options=[MESSAGE_SENDER_AI, MESSAGE_SENDER_USER],\n            value=MESSAGE_SENDER_AI,\n            advanced=True,\n            info=\"Type of sender.\",\n        ),\n        MessageTextInput(\n            name=\"sender_name\",\n            display_name=\"Sender Name\",\n            info=\"Name of the sender.\",\n            value=MESSAGE_SENDER_NAME_AI,\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"session_id\",\n            display_name=\"Session ID\",\n            info=\"The session ID of the chat. If empty, the current session ID parameter will be used.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"data_template\",\n            display_name=\"Data Template\",\n            value=\"{text}\",\n            advanced=True,\n            info=\"Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.\",\n        ),\n        MessageTextInput(\n            name=\"background_color\",\n            display_name=\"Background Color\",\n            info=\"The background color of the icon.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"chat_icon\",\n            display_name=\"Icon\",\n            info=\"The icon of the message.\",\n            advanced=True,\n        ),\n        MessageTextInput(\n            name=\"text_color\",\n            display_name=\"Text Color\",\n            info=\"The text color of the name\",\n            advanced=True,\n        ),\n        BoolInput(\n            name=\"clean_data\",\n            display_name=\"Basic Clean Data\",\n            value=True,\n            info=\"Whether to clean the data\",\n            advanced=True,\n        ),\n    ]\n    outputs = [\n        Output(\n            display_name=\"Message\",\n            name=\"message\",\n            method=\"message_response\",\n        ),\n    ]\n\n    def _build_source(self, id_: str | None, display_name: str | None, source: str | None) -> Source:\n        source_dict = {}\n        if id_:\n            source_dict[\"id\"] = id_\n        if display_name:\n            source_dict[\"display_name\"] = display_name\n        if source:\n            # Handle case where source is a ChatOpenAI object\n            if hasattr(source, \"model_name\"):\n                source_dict[\"source\"] = source.model_name\n            elif hasattr(source, \"model\"):\n                source_dict[\"source\"] = str(source.model)\n            else:\n                source_dict[\"source\"] = str(source)\n        return Source(**source_dict)\n\n    async def message_response(self) -> Message:\n        # First convert the input to string if needed\n        text = self.convert_to_string()\n\n        # Get source properties\n        source, icon, display_name, source_id = self.get_properties_from_source_component()\n        background_color = self.background_color\n        text_color = self.text_color\n        if self.chat_icon:\n            icon = self.chat_icon\n\n        # Create or use existing Message object\n        if isinstance(self.input_value, Message):\n            message = self.input_value\n            # Update message properties\n            message.text = text\n        else:\n            message = Message(text=text)\n\n        # Set message properties\n        message.sender = self.sender\n        message.sender_name = self.sender_name\n        message.session_id = self.session_id\n        message.flow_id = self.graph.flow_id if hasattr(self, \"graph\") else None\n        message.properties.source = self._build_source(source_id, display_name, source)\n        message.properties.icon = icon\n        message.properties.background_color = background_color\n        message.properties.text_color = text_color\n\n        # Store message if needed\n        if self.session_id and self.should_store_message:\n            stored_message = await self.send_message(message)\n            self.message.value = stored_message\n            message = stored_message\n\n        self.status = message\n        return message\n\n    def _validate_input(self) -> None:\n        \"\"\"Validate the input data and raise ValueError if invalid.\"\"\"\n        if self.input_value is None:\n            msg = \"Input data cannot be None\"\n            raise ValueError(msg)\n        if isinstance(self.input_value, list) and not all(\n            isinstance(item, Message | Data | DataFrame | str) for item in self.input_value\n        ):\n            invalid_types = [\n                type(item).__name__\n                for item in self.input_value\n                if not isinstance(item, Message | Data | DataFrame | str)\n            ]\n            msg = f\"Expected Data or DataFrame or Message or str, got {invalid_types}\"\n            raise TypeError(msg)\n        if not isinstance(\n            self.input_value,\n            Message | Data | DataFrame | str | list | Generator | type(None),\n        ):\n            type_name = type(self.input_value).__name__\n            msg = f\"Expected Data or DataFrame or Message or str, Generator or None, got {type_name}\"\n            raise TypeError(msg)\n\n    def _serialize_data(self, data: Data) -> str:\n        \"\"\"Serialize Data object to JSON string.\"\"\"\n        # Convert data.data to JSON-serializable format\n        serializable_data = jsonable_encoder(data.data)\n        # Serialize with orjson, enabling pretty printing with indentation\n        json_bytes = orjson.dumps(serializable_data, option=orjson.OPT_INDENT_2)\n        # Convert bytes to string and wrap in Markdown code blocks\n        return \"```json\\n\" + json_bytes.decode(\"utf-8\") + \"\\n```\"\n\n    def _safe_convert(self, data: Any) -> str:\n        \"\"\"Safely convert input data to string.\"\"\"\n        try:\n            if isinstance(data, str):\n                return data\n            if isinstance(data, Message):\n                return data.get_text()\n            if isinstance(data, Data):\n                return self._serialize_data(data)\n            if isinstance(data, DataFrame):\n                if self.clean_data:\n                    # Remove empty rows\n                    data = data.dropna(how=\"all\")\n                    # Remove empty lines in each cell\n                    data = data.replace(r\"^\\s*$\", \"\", regex=True)\n                    # Replace multiple newlines with a single newline\n                    data = data.replace(r\"\\n+\", \"\\n\", regex=True)\n\n                # Replace pipe characters to avoid markdown table issues\n                processed_data = data.replace(r\"\\|\", r\"\\\\|\", regex=True)\n\n                processed_data = processed_data.map(\n                    lambda x: str(x).replace(\"\\n\", \"<br/>\") if isinstance(x, str) else x\n                )\n\n                return processed_data.to_markdown(index=False)\n            return str(data)\n        except (ValueError, TypeError, AttributeError) as e:\n            msg = f\"Error converting data: {e!s}\"\n            raise ValueError(msg) from e\n\n    def convert_to_string(self) -> str | Generator[Any, None, None]:\n        \"\"\"Convert input data to string with proper error handling.\"\"\"\n        self._validate_input()\n        if isinstance(self.input_value, list):\n            return \"\\n\".join([self._safe_convert(item) for item in self.input_value])\n        if isinstance(self.input_value, Generator):\n            return self.input_value\n        return self._safe_convert(self.input_value)\n"
              },
              "data_template": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Data Template",
                "dynamic": false,
                "info": "Template to convert Data to Text. If left empty, it will be dynamically set to the Data's text key.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "data_template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{text}"
              },
              "input_value": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Text",
                "dynamic": false,
                "info": "Message to be passed as output.",
                "input_types": [
                  "Data",
                  "DataFrame",
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "input_value",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Type of sender.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Name of the sender.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "AI"
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "should_store_message": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Store Messages",
                "dynamic": false,
                "info": "Store the message in the history.",
                "list": false,
                "list_add_label": "Add More",
                "name": "should_store_message",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "text_color": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Text Color",
                "dynamic": false,
                "info": "The text color of the name",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "text_color",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              }
            },
            "tool_mode": false
          },
          "showNode": false,
          "type": "ChatOutput"
        },
        "id": "ChatOutput-ggq1G",
        "measured": {
          "height": 65,
          "width": 192
        },
        "position": {
          "x": 2145,
          "y": 660
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "Agent-Oloh8",
          "node": {
            "base_classes": [
              "Message"
            ],
            "beta": false,
            "category": "agents",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Define the agent's instructions, then enter a task to complete using tools.",
            "display_name": "Agent",
            "documentation": "",
            "edited": false,
            "field_order": [
              "agent_llm",
              "max_tokens",
              "model_kwargs",
              "json_mode",
              "model_name",
              "openai_api_base",
              "api_key",
              "temperature",
              "seed",
              "max_retries",
              "timeout",
              "system_prompt",
              "tools",
              "input_value",
              "handle_parsing_errors",
              "verbose",
              "max_iterations",
              "agent_description",
              "memory",
              "sender",
              "sender_name",
              "n_messages",
              "session_id",
              "order",
              "template",
              "add_current_date_tool"
            ],
            "frozen": false,
            "icon": "bot",
            "key": "Agent",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Response",
                "hidden": false,
                "method": "message_response",
                "name": "response",
                "selected": "Message",
                "tool_mode": true,
                "types": [
                  "Message"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 1.1732828199964098e-19,
            "template": {
              "_type": "Component",
              "add_current_date_tool": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Current Date",
                "dynamic": false,
                "info": "If true, will add a tool to the agent that returns the current date.",
                "list": false,
                "list_add_label": "Add More",
                "name": "add_current_date_tool",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "agent_description": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Agent Description [Deprecated]",
                "dynamic": false,
                "info": "The description of the agent. This is only used when in Tool Mode. Defaults to 'A helpful assistant with access to the following tools:' and tools are added dynamically. This feature is deprecated and will be removed in future versions.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "agent_description",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "A helpful assistant with access to the following tools:"
              },
              "agent_llm": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Model Provider",
                "dynamic": false,
                "info": "The provider of the language model that the agent will use to generate responses.",
                "input_types": [],
                "name": "agent_llm",
                "options": [
                  "Amazon Bedrock",
                  "Anthropic",
                  "Azure OpenAI",
                  "Google Generative AI",
                  "Groq",
                  "NVIDIA",
                  "OpenAI",
                  "SambaNova",
                  "Custom"
                ],
                "options_metadata": [
                  {
                    "icon": "Amazon"
                  },
                  {
                    "icon": "Anthropic"
                  },
                  {
                    "icon": "Azure"
                  },
                  {
                    "icon": "GoogleGenerativeAI"
                  },
                  {
                    "icon": "Groq"
                  },
                  {
                    "icon": "NVIDIA"
                  },
                  {
                    "icon": "OpenAI"
                  },
                  {
                    "icon": "SambaNova"
                  },
                  {
                    "icon": "brain"
                  }
                ],
                "placeholder": "",
                "real_time_refresh": true,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "OpenAI"
              },
              "api_key": {
                "_input_type": "SecretStrInput",
                "advanced": false,
                "display_name": "OpenAI API Key",
                "dynamic": false,
                "info": "The OpenAI API Key to use for the OpenAI model.",
                "input_types": [],
                "load_from_db": true,
                "name": "api_key",
                "password": true,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "str",
                "value": ""
              },
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import StructuredTool\n\nfrom langflow.base.agents.agent import LCToolsAgentComponent\nfrom langflow.base.agents.events import ExceptionWithMessageError\nfrom langflow.base.models.model_input_constants import (\n    ALL_PROVIDER_FIELDS,\n    MODEL_DYNAMIC_UPDATE_FIELDS,\n    MODEL_PROVIDERS_DICT,\n    MODELS_METADATA,\n)\nfrom langflow.base.models.model_utils import get_model_name\nfrom langflow.components.helpers import CurrentDateComponent\nfrom langflow.components.helpers.memory import MemoryComponent\nfrom langflow.components.langchain_utilities.tool_calling import ToolCallingAgentComponent\nfrom langflow.custom.utils import update_component_build_config\nfrom langflow.io import BoolInput, DropdownInput, MultilineInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema.dotdict import dotdict\nfrom langflow.schema.message import Message\n\n\ndef set_advanced_true(component_input):\n    component_input.advanced = True\n    return component_input\n\n\nclass AgentComponent(ToolCallingAgentComponent):\n    display_name: str = \"Agent\"\n    description: str = \"Define the agent's instructions, then enter a task to complete using tools.\"\n    icon = \"bot\"\n    beta = False\n    name = \"Agent\"\n\n    memory_inputs = [set_advanced_true(component_input) for component_input in MemoryComponent().inputs]\n\n    inputs = [\n        DropdownInput(\n            name=\"agent_llm\",\n            display_name=\"Model Provider\",\n            info=\"The provider of the language model that the agent will use to generate responses.\",\n            options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n            value=\"OpenAI\",\n            real_time_refresh=True,\n            input_types=[],\n            options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())] + [{\"icon\": \"brain\"}],\n        ),\n        *MODEL_PROVIDERS_DICT[\"OpenAI\"][\"inputs\"],\n        MultilineInput(\n            name=\"system_prompt\",\n            display_name=\"Agent Instructions\",\n            info=\"System Prompt: Initial instructions and context provided to guide the agent's behavior.\",\n            value=\"You are a helpful assistant that can use tools to answer questions and perform tasks.\",\n            advanced=False,\n        ),\n        *LCToolsAgentComponent._base_inputs,\n        *memory_inputs,\n        BoolInput(\n            name=\"add_current_date_tool\",\n            display_name=\"Current Date\",\n            advanced=True,\n            info=\"If true, will add a tool to the agent that returns the current date.\",\n            value=True,\n        ),\n    ]\n    outputs = [Output(name=\"response\", display_name=\"Response\", method=\"message_response\")]\n\n    async def message_response(self) -> Message:\n        try:\n            # Get LLM model and validate\n            llm_model, display_name = self.get_llm()\n            if llm_model is None:\n                msg = \"No language model selected. Please choose a model to proceed.\"\n                raise ValueError(msg)\n            self.model_name = get_model_name(llm_model, display_name=display_name)\n\n            # Get memory data\n            self.chat_history = await self.get_memory_data()\n\n            # Add current date tool if enabled\n            if self.add_current_date_tool:\n                if not isinstance(self.tools, list):  # type: ignore[has-type]\n                    self.tools = []\n                current_date_tool = (await CurrentDateComponent(**self.get_base_args()).to_toolkit()).pop(0)\n                if not isinstance(current_date_tool, StructuredTool):\n                    msg = \"CurrentDateComponent must be converted to a StructuredTool\"\n                    raise TypeError(msg)\n                self.tools.append(current_date_tool)\n\n            # Validate tools\n            if not self.tools:\n                msg = \"Tools are required to run the agent. Please add at least one tool.\"\n                raise ValueError(msg)\n\n            # Set up and run agent\n            self.set(\n                llm=llm_model,\n                tools=self.tools,\n                chat_history=self.chat_history,\n                input_value=self.input_value,\n                system_prompt=self.system_prompt,\n            )\n            agent = self.create_agent_runnable()\n            return await self.run_agent(agent)\n\n        except (ValueError, TypeError, KeyError) as e:\n            logger.error(f\"{type(e).__name__}: {e!s}\")\n            raise\n        except ExceptionWithMessageError as e:\n            logger.error(f\"ExceptionWithMessageError occurred: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error: {e!s}\")\n            raise\n\n    async def get_memory_data(self):\n        memory_kwargs = {\n            component_input.name: getattr(self, f\"{component_input.name}\") for component_input in self.memory_inputs\n        }\n        # filter out empty values\n        memory_kwargs = {k: v for k, v in memory_kwargs.items() if v is not None}\n\n        return await MemoryComponent(**self.get_base_args()).set(**memory_kwargs).retrieve_messages()\n\n    def get_llm(self):\n        if not isinstance(self.agent_llm, str):\n            return self.agent_llm, None\n\n        try:\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if not provider_info:\n                msg = f\"Invalid model provider: {self.agent_llm}\"\n                raise ValueError(msg)\n\n            component_class = provider_info.get(\"component_class\")\n            display_name = component_class.display_name\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\", \"\")\n\n            return self._build_llm_model(component_class, inputs, prefix), display_name\n\n        except Exception as e:\n            logger.error(f\"Error building {self.agent_llm} language model: {e!s}\")\n            msg = f\"Failed to initialize language model: {e!s}\"\n            raise ValueError(msg) from e\n\n    def _build_llm_model(self, component, inputs, prefix=\"\"):\n        model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n        return component.set(**model_kwargs).build_model()\n\n    def set_component_params(self, component):\n        provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n        if provider_info:\n            inputs = provider_info.get(\"inputs\")\n            prefix = provider_info.get(\"prefix\")\n            model_kwargs = {input_.name: getattr(self, f\"{prefix}{input_.name}\") for input_ in inputs}\n\n            return component.set(**model_kwargs)\n        return component\n\n    def delete_fields(self, build_config: dotdict, fields: dict | list[str]) -> None:\n        \"\"\"Delete specified fields from build_config.\"\"\"\n        for field in fields:\n            build_config.pop(field, None)\n\n    def update_input_types(self, build_config: dotdict) -> dotdict:\n        \"\"\"Update input types for all fields in build_config.\"\"\"\n        for key, value in build_config.items():\n            if isinstance(value, dict):\n                if value.get(\"input_types\") is None:\n                    build_config[key][\"input_types\"] = []\n            elif hasattr(value, \"input_types\") and value.input_types is None:\n                value.input_types = []\n        return build_config\n\n    async def update_build_config(\n        self, build_config: dotdict, field_value: str, field_name: str | None = None\n    ) -> dotdict:\n        # Iterate over all providers in the MODEL_PROVIDERS_DICT\n        # Existing logic for updating build_config\n        if field_name in (\"agent_llm\",):\n            build_config[\"agent_llm\"][\"value\"] = field_value\n            provider_info = MODEL_PROVIDERS_DICT.get(field_value)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call the component class's update_build_config method\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n\n            provider_configs: dict[str, tuple[dict, list[dict]]] = {\n                provider: (\n                    MODEL_PROVIDERS_DICT[provider][\"fields\"],\n                    [\n                        MODEL_PROVIDERS_DICT[other_provider][\"fields\"]\n                        for other_provider in MODEL_PROVIDERS_DICT\n                        if other_provider != provider\n                    ],\n                )\n                for provider in MODEL_PROVIDERS_DICT\n            }\n            if field_value in provider_configs:\n                fields_to_add, fields_to_delete = provider_configs[field_value]\n\n                # Delete fields from other providers\n                for fields in fields_to_delete:\n                    self.delete_fields(build_config, fields)\n\n                # Add provider-specific fields\n                if field_value == \"OpenAI\" and not any(field in build_config for field in fields_to_add):\n                    build_config.update(fields_to_add)\n                else:\n                    build_config.update(fields_to_add)\n                # Reset input types for agent_llm\n                build_config[\"agent_llm\"][\"input_types\"] = []\n            elif field_value == \"Custom\":\n                # Delete all provider fields\n                self.delete_fields(build_config, ALL_PROVIDER_FIELDS)\n                # Update with custom component\n                custom_component = DropdownInput(\n                    name=\"agent_llm\",\n                    display_name=\"Language Model\",\n                    options=[*sorted(MODEL_PROVIDERS_DICT.keys()), \"Custom\"],\n                    value=\"Custom\",\n                    real_time_refresh=True,\n                    input_types=[\"LanguageModel\"],\n                    options_metadata=[MODELS_METADATA[key] for key in sorted(MODELS_METADATA.keys())]\n                    + [{\"icon\": \"brain\"}],\n                )\n                build_config.update({\"agent_llm\": custom_component.to_dict()})\n            # Update input types for all fields\n            build_config = self.update_input_types(build_config)\n\n            # Validate required keys\n            default_keys = [\n                \"code\",\n                \"_type\",\n                \"agent_llm\",\n                \"tools\",\n                \"input_value\",\n                \"add_current_date_tool\",\n                \"system_prompt\",\n                \"agent_description\",\n                \"max_iterations\",\n                \"handle_parsing_errors\",\n                \"verbose\",\n            ]\n            missing_keys = [key for key in default_keys if key not in build_config]\n            if missing_keys:\n                msg = f\"Missing required keys in build_config: {missing_keys}\"\n                raise ValueError(msg)\n        if (\n            isinstance(self.agent_llm, str)\n            and self.agent_llm in MODEL_PROVIDERS_DICT\n            and field_name in MODEL_DYNAMIC_UPDATE_FIELDS\n        ):\n            provider_info = MODEL_PROVIDERS_DICT.get(self.agent_llm)\n            if provider_info:\n                component_class = provider_info.get(\"component_class\")\n                component_class = self.set_component_params(component_class)\n                prefix = provider_info.get(\"prefix\")\n                if component_class and hasattr(component_class, \"update_build_config\"):\n                    # Call each component class's update_build_config method\n                    # remove the prefix from the field_name\n                    if isinstance(field_name, str) and isinstance(prefix, str):\n                        field_name = field_name.replace(prefix, \"\")\n                    build_config = await update_component_build_config(\n                        component_class, build_config, field_value, \"model_name\"\n                    )\n        return dotdict({k: v.to_dict() if hasattr(v, \"to_dict\") else v for k, v in build_config.items()})\n"
              },
              "handle_parsing_errors": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Handle Parse Errors",
                "dynamic": false,
                "info": "Should the Agent fix errors when reading user input for better processing?",
                "list": false,
                "list_add_label": "Add More",
                "name": "handle_parsing_errors",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "input_value": {
                "_input_type": "MessageTextInput",
                "advanced": false,
                "display_name": "Input",
                "dynamic": false,
                "info": "The input provided by the user for the agent to process.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "input_value",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": true,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "json_mode": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "JSON Mode",
                "dynamic": false,
                "info": "If True, it will output JSON regardless of passing a schema.",
                "list": false,
                "list_add_label": "Add More",
                "name": "json_mode",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": false
              },
              "max_iterations": {
                "_input_type": "IntInput",
                "advanced": false,
                "display_name": "Max Iterations",
                "dynamic": false,
                "info": "The maximum number of attempts the agent can make to complete its task before it stops.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_iterations",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 200
              },
              "max_retries": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Retries",
                "dynamic": false,
                "info": "The maximum number of retries to make when generating.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_retries",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 5
              },
              "max_tokens": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Max Tokens",
                "dynamic": false,
                "info": "The maximum number of tokens to generate. Set to 0 for unlimited tokens.",
                "list": false,
                "list_add_label": "Add More",
                "name": "max_tokens",
                "placeholder": "",
                "range_spec": {
                  "max": 128000,
                  "min": 0,
                  "step": 0.1,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": ""
              },
              "memory": {
                "_input_type": "HandleInput",
                "advanced": true,
                "display_name": "External Memory",
                "dynamic": false,
                "info": "Retrieve messages from an external memory. If empty, it will use the Langflow tables.",
                "input_types": [
                  "Memory"
                ],
                "list": false,
                "list_add_label": "Add More",
                "name": "memory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "model_kwargs": {
                "_input_type": "DictInput",
                "advanced": true,
                "display_name": "Model Kwargs",
                "dynamic": false,
                "info": "Additional keyword arguments to pass to the model.",
                "list": false,
                "list_add_label": "Add More",
                "name": "model_kwargs",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "type": "dict",
                "value": {}
              },
              "model_name": {
                "_input_type": "DropdownInput",
                "advanced": false,
                "combobox": true,
                "dialog_inputs": {},
                "display_name": "Model Name",
                "dynamic": false,
                "info": "To see the model names, first choose a provider. Then, enter your API key and click the refresh button next to the model name.",
                "name": "model_name",
                "options": [
                  "gpt-4o-mini",
                  "gpt-4o",
                  "gpt-4.1",
                  "gpt-4.1-mini",
                  "gpt-4.1-nano",
                  "gpt-4.5-preview",
                  "gpt-4-turbo",
                  "gpt-4-turbo-preview",
                  "gpt-4",
                  "gpt-3.5-turbo",
                  "o1"
                ],
                "options_metadata": [],
                "placeholder": "",
                "real_time_refresh": false,
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "gpt-4.1"
              },
              "n_messages": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Number of Messages",
                "dynamic": false,
                "info": "Number of messages to retrieve.",
                "list": false,
                "list_add_label": "Add More",
                "name": "n_messages",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 100
              },
              "openai_api_base": {
                "_input_type": "StrInput",
                "advanced": true,
                "display_name": "OpenAI API Base",
                "dynamic": false,
                "info": "The base URL of the OpenAI API. Defaults to https://api.openai.com/v1. You can change this to use other APIs like JinaChat, LocalAI and Prem.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "openai_api_base",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "order": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Order",
                "dynamic": false,
                "info": "Order of the messages.",
                "name": "order",
                "options": [
                  "Ascending",
                  "Descending"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Ascending"
              },
              "seed": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Seed",
                "dynamic": false,
                "info": "The seed controls the reproducibility of the job.",
                "list": false,
                "list_add_label": "Add More",
                "name": "seed",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 1
              },
              "sender": {
                "_input_type": "DropdownInput",
                "advanced": true,
                "combobox": false,
                "dialog_inputs": {},
                "display_name": "Sender Type",
                "dynamic": false,
                "info": "Filter by sender type.",
                "name": "sender",
                "options": [
                  "Machine",
                  "User",
                  "Machine and User"
                ],
                "options_metadata": [],
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "toggle": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "Machine and User"
              },
              "sender_name": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Sender Name",
                "dynamic": false,
                "info": "Filter by sender name.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sender_name",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "session_id": {
                "_input_type": "MessageTextInput",
                "advanced": true,
                "display_name": "Session ID",
                "dynamic": false,
                "info": "The session ID of the chat. If empty, the current session ID parameter will be used.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "session_id",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "system_prompt": {
                "_input_type": "MultilineInput",
                "advanced": false,
                "copy_field": false,
                "display_name": "Agent Instructions",
                "dynamic": false,
                "info": "System Prompt: Initial instructions and context provided to guide the agent's behavior.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "system_prompt",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "# Role & Objective\nYou are the **Component Maker Agent**, an advanced AI assistant specialized in creating and modifying custom components for the Langflow framework. Your goal is to help users develop high-quality, functional components by generating well-structured, efficient, and error-free Python code. You excel at file manipulation and code editing to ensure components are properly integrated into existing codebases. You should adhere to the latest Langflow best practices and leverage your knowledge of the existing codebase.\n\nYour core mission is to both **create new components** and **modify existing components** with precision, using the available file manipulation tools to seamlessly integrate new code into the user's environment.\n\n# Agent Behavior\n- **PERSISTENCE**: Always continue working until the user's component request is completely resolved. Never stop in the middle of creating or modifying a component. Only terminate your turn when you are sure that the task is complete.\n- **TOOL USAGE**: Always use file manipulation tools to view, create, or edit files. Never guess about file structure or content when you can check it directly. If you are not sure about file content or codebase structure, use your tools to read files and gather the relevant information.\n- **PLANNING**: Plan your approach thoroughly before making edits, examining existing code first to understand patterns and conventions. Think step by step about what the component needs to do and how to implement it within the existing codebase.\n\n## Requirements Gathering\nWhen helping users create components, start by gathering these key requirements:\n\n1. **Component Name:** What should the component be called?\n2. **Description:** What does the component do?\n3. **Inputs:** What inputs will the component need? (type, name, description for each)\n4. **Outputs:** What should the component output? \n5. **Category:** Which component category should this fit under in `src/backend/base/langflow/components`?\n6. **Icon:** What icon should represent this component?\n\n# Component Structure & Metadata\n\n## Core Component Structure\n```python\nfrom langflow.custom import Component\nfrom langflow.io import StrInput, Output\nfrom langflow.schema import Data\n\nclass YourComponent(Component):\n    display_name = \"Your Component Name\"\n    description = \"What your component does\"\n    icon = \"icon-name\"  # Lucide icon or custom icon\n    name = \"YourComponentClassName\"\n    \n    # Optional flags\n    beta = True       # Indicates a component that's still being tested\n    legacy = True     # Indicates a component that may be deprecated in future\n    \n    # Metadata dictionary\n    metadata = {\n        \"keywords\": [\n            \"keyword1\",\n            \"keyword2\",\n        ],\n    }\n    \n    # Inputs definition\n    inputs = [\n        StrInput(\n            name=\"input_name\",\n            display_name=\"Input Display Name\",\n            info=\"Description of the input\",\n            required=True,\n            # other parameters...\n        ),\n        # more inputs...\n    ]\n    \n    # Outputs definition\n    outputs = [\n        Output(display_name=\"Output Name\", name=\"output_method_name\", method=\"method_name\"),\n        # more outputs...\n    ]\n    \n    # Component methods\n    def method_name(self) -> Data:\n        \"\"\"Implementation of the component's functionality.\"\"\"\n        try:\n            # Component logic here\n            result = self._process_data()\n            return Data(data=result)\n        except Exception as e:\n            self.status = f\"Error: {str(e)}\"\n            return Data(data={\"error\": str(e)})\n```\n\n## Icon Implementation Guide\nProper icon implementation is essential for component recognition and UX. Follow these guidelines:\n\n### Backend (Python) Icon Configuration\n- Set the `icon` attribute in your component class:\n  ```python\n  class YourComponent(Component):\n      display_name = \"Your Component Name\"\n      description = \"What your component does\"\n      icon = \"IconName\"  # Must match frontend icon mapping\n  ```\n\n### Icon Selection Options\n1. **Use Lucide Icons** (preferred for most components)\n   - Select from [Lucide icons](https://lucide.dev/icons)\n   - Use the kebab-case name (e.g., `icon = \"database\"`, `icon = \"git-merge\"`)\n\n2. **Use Custom Icons** (for specific services/brands)\n   - For branded components (e.g., MongoDB, AWS, OpenAI), use a custom icon\n   - First check if the icon already exists in the codebase\n   - For missing icons, use a lucide icon as a placeholder and note that a custom icon should be created\n\n# Component Features & Implementation\n\n## Input Types\nDefine inputs within the `inputs` attribute of your component class:\n\n```python\ninputs = [\n    StrInput(\n        name=\"text_input\",\n        display_name=\"Text Input\",\n        info=\"Description of what this input does\",\n        required=True,\n        value=\"Default value\",  # Optional default value\n        is_list=False,          # Set to True for list inputs\n        advanced=False,         # Set to True for advanced options\n        dynamic=False,          # Set to True for dynamically updated fields\n        refresh_button=False,   # Set to True to add refresh button\n        input_types=[\"Data\"],   # Restrict input types\n        tool_mode=False,        # Set to True for tool interface visibility\n        real_time_refresh=False, # Set to True for real-time UI updates\n    ),\n    # Other input types...\n]\n```\n\n### Common Input Types\n- `StrInput`: Text input\n- `BoolInput`: Boolean/checkbox input\n- `IntInput`: Integer number input\n- `FloatInput`: Floating-point number input\n- `DropdownInput`: Selection dropdown\n- `MultilineInput`: Multi-line text area\n- `DataInput`: Data object input\n- `DictInput`: Dictionary/key-value input\n- `CodeInput`: Code input with syntax highlighting\n- `SecretStrInput`: Password/key input that masks values\n- `TabInput`: Tabbed interface for organizing options\n- `TableInput`: Table-like input with custom schema\n- `MessageTextInput`: Text input specialized for chat messages\n- `SliderInput`: Slider for numeric range selection\n- `SortableListInput`: List with sortable items\n\n## Output Types\nDefine outputs that users can connect to other components:\n\n```python\noutputs = [\n    Output(display_name=\"Result\", name=\"output_name\", method=\"method_name\"),\n    # Other outputs as needed...\n]\n```\n\nEach output references a method in your component that will be called when the output is triggered. Output methods must return one of these types:\n- `Data`: General data container, can hold any Python object\n- `DataFrame`: For tabular data (pandas DataFrames)\n- `Message`: For chat/message responses\n\n## Dynamic UI with update_build_config\nFor components that need dynamic UI behavior based on user selections:\n\n```python\nasync def update_build_config(self):\n    \"\"\"Dynamically update UI based on component state.\"\"\"\n    if not self.build_config:\n        return\n        \n    # Example: Show/hide fields based on mode selection\n    if self.mode == \"Mode1\":\n        self.build_config[\"field1\"][\"show\"] = True\n        self.build_config[\"field2\"][\"show\"] = False\n    elif self.mode == \"Mode2\":\n        self.build_config[\"field1\"][\"show\"] = False\n        self.build_config[\"field2\"][\"show\"] = True\n```\n\n## Using Enums for Component Options\nWhen a component needs to handle specific options or modes, use Python's `Enum` class for better code organization, type safety, and readability:\n\n```python\nfrom enum import Enum\nfrom typing import cast\n\nclass DataOperation(str, Enum):\n    CONCATENATE = \"Concatenate\"\n    APPEND = \"Append\"\n    MERGE = \"Merge\"\n    JOIN = \"Join\"\n\nclass MergeDataComponent(Component):\n    # ... other component attributes ...\n    \n    inputs = [\n        # ... other inputs ...\n        DropdownInput(\n            name=\"operation\",\n            display_name=\"Operation Type\",\n            options=[op.value for op in DataOperation],\n            value=DataOperation.CONCATENATE.value,\n        ),\n    ]\n    \n    def combine_data(self) -> DataFrame:\n        # Convert string value to enum for type safety\n        operation = DataOperation(self.operation)\n        \n        # Use enum in switch-like statements\n        if operation == DataOperation.CONCATENATE:\n            # Handle concatenation\n            pass\n        elif operation == DataOperation.APPEND:\n            # Handle append\n            pass\n        # ... other operations ...\n```\n\n## Error Handling and Logging\nImplement robust error handling with specific error messages:\n\n```python\ndef process_data(self) -> Data:\n    try:\n        # Validate inputs first\n        if not self.input_data:\n            self.status = \"Input data is empty\"\n            return Data(data={})\n            \n        if not self.filter_key:\n            self.status = \"Filter key is required\"\n            return Data(data={})\n        \n        # Main processing logic\n        result = self._perform_operation()\n        self.status = \"Operation successful\"\n        return result\n    except ValueError as e:\n        # Handle specific error types differently\n        logger.error(f\"Value error in {self.display_name}: {e}\")\n        self.status = f\"Invalid value: {str(e)}\"\n        return Data(data={\"error\": str(e)})\n    except Exception as e:\n        # Catch all other errors\n        logger.exception(f\"Unexpected error in {self.display_name}\")\n        self.status = f\"Error processing data: {str(e)}\"\n        return Data(data={\"error\": str(e)})\n```\n\n# Component Development Workflow\n\nFollow these step-by-step processes for both new components and modifications:\n\n## For New Components\n\n1. **Gather Requirements**\n   - Confirm exactly what the component should do\n   - Identify all inputs (types, descriptions, defaults)\n   - Determine outputs and return types\n   - Choose appropriate category and icon\n\n2. **Set Up Version Control**\n   - Check the current git status with `functions.git_status`\n   - Create a new feature branch with a descriptive name: `functions.git_branch` and `functions.git_checkout`\n   - The branch name should follow convention: `feature/component-name`\n\n3. **Explore Existing Codebase**\n   - View similar components for reference using `functions.view_file`\n   - Analyze structure with `functions.find_code_structure`\n   - Note common patterns, imports, and conventions\n   - Study existing test files to understand testing patterns\n\n4. **Plan Component Implementation**\n   - Decide on class hierarchy and inheritance\n   - Plan input/output configuration \n   - Design core functionality methods\n   - Consider error handling strategy\n   - Plan test cases for functionality validation\n\n5. **Implement the Component**\n   - Create the component file with `functions.create_file`\n   - **CRITICAL**: Place component in correct location: `src/backend/base/langflow/components/{category}/{component_name}.py`\n   - Implement the component class with proper metadata\n   - Add inputs and outputs with clear descriptions\n   - Write core logic methods with proper error handling\n   - Add type annotations and docstrings\n   - Commit changes with `functions.git_add` and `functions.git_commit`\n\n6. **Implement Component Tests**\n   - Create test file using `functions.create_file`\n   - **CRITICAL**: Place test file in correct location: `src/backend/tests/unit/components/{category}/test_{component_name}.py`\n   - Implement test fixtures for the component\n   - Write test methods for each component functionality\n   - Add tests for edge cases and error handling\n   - Use proper pytest assertions and mocks as needed\n   - Commit test implementation with git\n\n7. **Run and Validate Tests**\n   - Start a shell session with `functions.start_shell_session`\n   - Run the test command with `functions.run_command` using exact format:\n     `uv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v`\n   - Check test results and fix failing tests\n   - Iterate until all tests pass\n   - Commit final working changes\n\n## For Modifying Existing Components\n\n1. **Analyze Current Implementation**\n   - View the file with `functions.view_file`\n   - Examine structure with `functions.find_code_structure`\n   - Identify exactly what needs to change\n   - Check existing tests for the component\n\n2. **Set Up Version Control**\n   - Check current git status with `functions.git_status`\n   - Create a feature branch for your modification\n   - Use descriptive branch name like `fix/component-name-feature`\n\n3. **Create Modification Plan**\n   - List specific changes needed in order\n   - Identify potential side effects\n   - Plan precise edit locations\n   - Plan test updates needed\n\n4. **Execute Targeted Edits**\n   - Use `functions.edit_text` with specific context targeting\n   - Make incremental changes and verify each one\n   - Use appropriate context markers to ensure precision\n   - Commit incremental changes with `functions.git_commit`\n\n5. **Update or Add Tests**\n   - Update existing tests or add new tests for modified features\n   - **CRITICAL**: Tests must be in `src/backend/tests/unit/components/{category}/test_{component_name}.py`\n   - Ensure all new functionality is covered by tests\n   - Commit test changes\n\n6. **Test and Validate**\n   - Run tests with shell command using exact format:\n     `uv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v`\n   - Fix any failing tests\n   - Verify all requirements have been addressed\n   - Commit final working version\n\n# Component Testing Strategy\n\nTests are a critical part of component development to ensure reliability and maintainability. Follow these guidelines to create robust test suites for your components.\n\n## Test File Location and Structure\n\n**CRITICAL**: Tests must be placed in the correct directory structure:\n\n```\nsrc/backend/tests/unit/components/{category}/test_{component_name}.py\n```\n\n**CRITICAL**: Components must be placed in the correct directory structure:\n\n```\nsrc/backend/base/langflow/components/{category}/{component_name}.py\n```\n\nFor example:\n- Component: `src/backend/base/langflow/components/tools/calculator.py`\n- Test file: `src/backend/tests/unit/components/tools/test_calculator.py`\n- Component: `src/backend/base/langflow/components/data/merge_data.py`\n- Test file: `src/backend/tests/unit/components/data/test_merge_data.py`\n\n## Test Structure and Organization\n\nTests for components should follow the pytest framework conventions:\n\n```python\nimport pytest\nfrom unittest.mock import AsyncMock, MagicMock, patch\n\nfrom langflow.components.{category}.{component_file} import {ComponentClass}\nfrom tests.base import ComponentTestBaseWithoutClient, VersionComponentMapping\n\nclass Test{ComponentClass}(ComponentTestBaseWithoutClient):\n    @pytest.fixture\n    def component_class(self):\n        \"\"\"Return the component class to test.\"\"\"\n        return {ComponentClass}\n\n    @pytest.fixture\n    def default_kwargs(self):\n        \"\"\"Return the default kwargs for the component.\"\"\"\n        return {\n            \"param1\": \"default_value1\",\n            \"param2\": \"default_value2\",\n        }\n    \n    @pytest.fixture\n    def file_names_mapping(self) -> list[VersionComponentMapping]:\n        \"\"\"Return the file names mapping for different versions.\"\"\"\n        return []\n        \n    # Test methods go here\n    async def test_functionality(self, component_class, default_kwargs):\n        \"\"\"Test specific functionality of the component.\"\"\"\n        component = component_class(**default_kwargs)\n        # Set up test conditions\n        # Run functionality\n        # Assert expected results\n```\n\n## Running Tests\n\n**ALWAYS use this exact command format to run component tests:**\n\n```\nuv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v\n```\n\n**Examples:**\n- `uv run pytest src/backend/tests/unit/components/tools/test_calculator.py -v`\n- `uv run pytest src/backend/tests/unit/components/data/test_merge_data.py -v`\n- `uv run pytest src/backend/tests/unit/components/tools/test_mcp_component.py -v`\n\nFor more detailed output and coverage information:\n```\nuv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v --cov=langflow.components.{category}\n```\n\n## Test Types to Implement\n\nFor each component, implement these core test types:\n\n1. **Initialization Tests**\n   - Verify the component initializes with default parameters\n   - Check that required attributes are set correctly\n\n2. **Validation Tests**\n   - Test validation of required parameters\n   - Verify error handling for invalid inputs\n   - Test edge cases (empty values, type mismatches)\n\n3. **Core Functionality Tests**\n   - Test each method connected to component outputs\n   - Verify expected behavior for normal inputs\n   - Test error handling and recovery\n\n4. **Integration Tests**\n   - Test interaction with external dependencies\n   - Mock external services as needed\n   - Verify connectivity and data processing flows\n\n## Mocking Dependencies\n\nUse Python's unittest.mock to isolate the component from external dependencies:\n\n```python\n@patch(\"module.to.patch.function_name\")\nasync def test_with_mock(self, mock_function, component_class, default_kwargs):\n    # Configure mock\n    mock_function.return_value = expected_result\n    \n    # Initialize component and test\n    component = component_class(**default_kwargs)\n    result = await component.method_to_test()\n    \n    # Verify mock was called correctly\n    mock_function.assert_called_once_with(expected_args)\n    assert result == expected_output\n```\n\n## Running Tests\n\n**ALWAYS use this exact command format to run component tests:**\n\n```\nuv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v\n```\n\n**Examples:**\n- `uv run pytest src/backend/tests/unit/components/tools/test_calculator.py -v`\n- `uv run pytest src/backend/tests/unit/components/data/test_merge_data.py -v`\n- `uv run pytest src/backend/tests/unit/components/tools/test_mcp_component.py -v`\n\nFor more detailed output and coverage information:\n```\nuv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v --cov=langflow.components.{category}\n```\n\n## Testing Asynchronous Components\n\nMany components in Langflow use async functions. Test them like this:\n\n```python\nasync def test_async_method(self, component_class, default_kwargs):\n    component = component_class(**default_kwargs)\n    result = await component.async_method()\n    assert result == expected_result\n```\n\n## Test Fixtures\n\nCreate fixtures to reuse testing objects:\n\n```python\n@pytest.fixture\ndef mock_dependency(self):\n    \"\"\"Create a mock dependency for testing.\"\"\"\n    mock = MagicMock()\n    mock.method.return_value = expected_output\n    return mock\n```\n\n## Test Coverage Expectations\n\nComponent tests should aim for high coverage:\n- 80%+ overall test coverage\n- 100% coverage of public methods/API\n- All branches and error conditions should be tested\n\n## Exploration Phase\nBefore making any changes, thoroughly explore the codebase:\n\n1. **View and Understand Existing Files**\n   - Use `functions.view_file` to examine relevant files\n   - Look for patterns, conventions, and standard imports\n   - Note the project's style (indentation, naming, etc.)\n\n2. **Analyze Component Structure**\n   - Use `functions.find_code_structure` to identify classes, methods, and functions\n   - Map the inheritance hierarchy and understand component relationships\n   - Identify extension points and common design patterns\n\n3. **Search for Similar Components**\n   - Use `functions.search_code` to find similar components as reference\n   - Search for specific patterns, imports, or method signatures\n   - Look for reusable utility code or helper functions\n\n## Implementation Techniques\nApply precise editing techniques for different scenarios:\n\n1. **For New Components**\n   - Use `functions.create_file` with complete, well-structured code\n   - Follow naming conventions and import patterns from similar components\n   - Include detailed docstrings and type annotations\n\n2. **For Small Modifications**\n   - Use `functions.edit_text` with precise targeting:\n     - Specify `context_before` and `context_after` to ensure correct placement\n     - Use `line_number` when editing specific lines\n     - Set `use_regex=True` for more complex pattern matching\n\n3. **For Large Refactors**\n   - Combine `functions.view_file` and `functions.create_file` to replace entire files\n   - Use `functions.move_code_block` to reorganize large sections\n   - Break changes into multiple edits for better tracking\n\n# Example Component Implementations\n\n## Example 1: Advanced MCP Tools Component with Tests\n\n### Component Implementation\n\n```python\nimport re\nimport shutil\nfrom typing import Any\n\nfrom langchain_core.tools import StructuredTool\n\nfrom langflow.base.mcp.util import (\n    MCPSseClient,\n    MCPStdioClient,\n    create_input_schema_from_json_schema,\n    create_tool_coroutine,\n    create_tool_func,\n)\nfrom langflow.custom import Component\nfrom langflow.inputs import DropdownInput, TableInput\nfrom langflow.inputs.inputs import InputTypes\nfrom langflow.io import MessageTextInput, MultilineInput, Output, TabInput\nfrom langflow.io.schema import flatten_schema, schema_to_langflow_inputs\nfrom langflow.logging import logger\nfrom langflow.schema import DataFrame\n\n\ndef maybe_unflatten_dict(flat: dict[str, Any]) -> dict[str, Any]:\n    \"\"\"If any key looks nested (contains a dot or \"[index]\"), rebuild the full nested structure; otherwise return flat as is.\"\"\"\n    # Quick check: do we have any nested keys?\n    if not any(re.search(r\"\\.|\\[\\d+\\]\", key) for key in flat):\n        return flat\n\n    # Otherwise, unflatten into dicts/lists\n    nested: dict[str, Any] = {}\n    array_re = re.compile(r\"^(.+)\\[(\\d+)\\]$\")\n\n    for key, val in flat.items():\n        parts = key.split(\".\")\n        cur = nested\n        for i, part in enumerate(parts):\n            m = array_re.match(part)\n            # Array segment?\n            if m:\n                name, idx = m.group(1), int(m.group(2))\n                lst = cur.setdefault(name, [])\n                # Ensure list is big enough\n                while len(lst) <= idx:\n                    lst.append({})\n                if i == len(parts) - 1:\n                    lst[idx] = val\n                else:\n                    cur = lst[idx]\n            # Normal object key\n            elif i == len(parts) - 1:\n                cur[part] = val\n            else:\n                cur = cur.setdefault(part, {})\n\n    return nested\n\n\nclass MCPToolsComponent(Component):\n    schema_inputs: list[InputTypes] = []\n    stdio_client: MCPStdioClient = MCPStdioClient()\n    sse_client: MCPSseClient = MCPSseClient()\n    tools: list = []\n    tool_names: list[str] = []\n    _tool_cache: dict = {}  # Cache for tool objects\n    default_keys: list[str] = [\n        \"code\",\n        \"_type\",\n        \"mode\",\n        \"command\",\n        \"env\",\n        \"sse_url\",\n        \"tool_placeholder\",\n        \"tool_mode\",\n        \"tool\",\n        \"headers_input\",\n    ]\n\n    display_name = \"MCP Connection\"\n    description = \"Connect to an MCP server to use its tools.\"\n    icon = \"Mcp\"\n    name = \"MCPTools\"\n\n    inputs = [\n        TabInput(\n            name=\"mode\",\n            display_name=\"Mode\",\n            options=[\"Stdio\", \"SSE\"],\n            value=\"Stdio\",\n            info=\"Select the connection mode\",\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"command\",\n            display_name=\"MCP Command\",\n            info=\"Command for MCP stdio connection\",\n            value=\"uvx mcp-server-fetch\",\n            show=True,\n            refresh_button=True,\n        ),\n        MessageTextInput(\n            name=\"env\",\n            display_name=\"Env\",\n            info=\"Env vars to include in mcp stdio connection (i.e. DEBUG=true)\",\n            value=\"\",\n            is_list=True,\n            show=True,\n            tool_mode=False,\n            advanced=True,\n        ),\n        MultilineInput(\n            name=\"sse_url\",\n            display_name=\"MCP SSE URL\",\n            info=\"URL for MCP SSE connection\",\n            show=False,\n            refresh_button=True,\n            value=\"MCP_SSE\",\n            real_time_refresh=True,\n        ),\n        TableInput(\n            name=\"headers_input\",\n            display_name=\"Headers\",\n            info=\"Headers to include in the tool\",\n            show=False,\n            real_time_refresh=True,\n            table_schema=[\n                {\n                    \"name\": \"key\",\n                    \"display_name\": \"Header\",\n                    \"type\": \"str\",\n                    \"description\": \"Header name\",\n                },\n                {\n                    \"name\": \"value\",\n                    \"display_name\": \"Value\",\n                    \"type\": \"str\",\n                    \"description\": \"Header value\",\n                },\n            ],\n            value=[],\n            advanced=True,\n        ),\n        DropdownInput(\n            name=\"tool\",\n            display_name=\"Tool\",\n            options=[],\n            value=\"\",\n            info=\"Select the tool to execute\",\n            show=True,\n            required=True,\n            real_time_refresh=True,\n        ),\n        MessageTextInput(\n            name=\"tool_placeholder\",\n            display_name=\"Tool Placeholder\",\n            info=\"Placeholder for the tool\",\n            value=\"\",\n            show=False,\n            tool_mode=True,\n        ),\n    ]\n\n    outputs = [\n        Output(display_name=\"Response\", name=\"response\", method=\"build_output\"),\n    ]\n\n    async def update_build_config(self, build_config: dict, field_value: str, field_name: str | None = None) -> dict:\n        \"\"\"Toggle the visibility of connection-specific fields based on the selected mode.\"\"\"\n        try:\n            if field_name == \"mode\":\n                self.remove_non_default_keys(build_config)\n                build_config[\"tool\"][\"options\"] = []\n                if field_value == \"Stdio\":\n                    build_config[\"command\"][\"show\"] = True\n                    build_config[\"env\"][\"show\"] = True\n                    build_config[\"headers_input\"][\"show\"] = False\n                    build_config[\"sse_url\"][\"show\"] = False\n                elif field_value == \"SSE\":\n                    build_config[\"command\"][\"show\"] = False\n                    build_config[\"env\"][\"show\"] = False\n                    build_config[\"sse_url\"][\"show\"] = True\n                    build_config[\"sse_url\"][\"value\"] = \"MCP_SSE\"\n                    build_config[\"headers_input\"][\"show\"] = True\n                    return build_config\n            # ... (truncated for brevity - full implementation available)\n        except Exception as e:\n            msg = f\"Error in update_build_config: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n        else:\n            return build_config\n\n    async def build_output(self) -> DataFrame:\n        \"\"\"Build output with improved error handling and validation.\"\"\"\n        try:\n            await self.update_tools()\n            if self.tool != \"\":\n                exec_tool = self._tool_cache[self.tool]\n                tool_args = self.get_inputs_for_all_tools(self.tools)[self.tool]\n                kwargs = {}\n                for arg in tool_args:\n                    value = getattr(self, arg.name, None)\n                    if value:\n                        kwargs[arg.name] = value\n\n                unflattened_kwargs = maybe_unflatten_dict(kwargs)\n                output = await exec_tool.coroutine(**unflattened_kwargs)\n\n                tool_content = []\n                for item in output.content:\n                    item_dict = item.model_dump()\n                    tool_content.append(item_dict)\n                return DataFrame(data=tool_content)\n            return DataFrame(data=[{\"error\": \"You must select a tool\"}])\n        except Exception as e:\n            msg = f\"Error in build_output: {e!s}\"\n            logger.exception(msg)\n            raise ValueError(msg) from e\n```\n\n## Example 2: Web Search Component\n\n```python\nimport re\nfrom urllib.parse import parse_qs, unquote, urlparse\n\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nfrom langflow.custom import Component\nfrom langflow.io import IntInput, MessageTextInput, Output\nfrom langflow.schema import DataFrame\nfrom langflow.services.deps import get_settings_service\n\n\nclass WebSearchComponent(Component):\n    display_name = \"Web Search\"\n    description = (\n        \"Performs a basic DuckDuckGo search (HTML scraping) \"\n        \"and returns a DataFrame of titles, links, snippets, and fetched content.\"\n    )\n    icon = \"search\"\n    name = \"WebSearchNoAPI\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"query\",\n            display_name=\"Search Query\",\n            info=\"Keywords to search for.\",\n            tool_mode=True,\n            input_types=[],\n            required=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Timeout for the web search request.\",\n            value=5,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [Output(name=\"results\", display_name=\"Search Results\", method=\"perform_search\")]\n\n    def validate_url(self, string: str) -> bool:\n        url_regex = re.compile(\n            r\"^(https?:\\/\\/)?\" r\"(www\\.)?\" r\"([a-zA-Z0-9.-]+)\" r\"(\\.[a-zA-Z]{2,})?\" r\"(:\\d+)?\" r\"(\\/[^\\s]*)?$\",\n            re.IGNORECASE,\n        )\n        return bool(url_regex.match(string))\n\n    def ensure_url(self, url: str) -> str:\n        if not url.startswith((\"http://\", \"https://\")):\n            url = \"https://\" + url\n        if not self.validate_url(url):\n            msg = f\"Invalid URL: {url}\"\n            raise ValueError(msg)\n        return url\n\n    def _sanitize_query(self, query: str) -> str:\n        \"\"\"Sanitize search query.\"\"\"\n        # Remove potentially dangerous characters\n        return re.sub(r'[<>\"\\']', \"\", query.strip())\n\n    def perform_search(self) -> DataFrame:\n        query = self._sanitize_query(self.query)\n        if not query:\n            msg = \"Empty search query\"\n            raise ValueError(msg)\n        headers = {\"User-Agent\": get_settings_service().settings.user_agent}\n        params = {\"q\": query, \"kl\": \"us-en\"}\n        url = \"https://html.duckduckgo.com/html/\"\n\n        try:\n            response = requests.get(url, params=params, headers=headers, timeout=self.timeout)\n            response.raise_for_status()\n        except requests.RequestException as e:\n            self.status = f\"Failed request: {e!s}\"\n            return DataFrame(pd.DataFrame([{\"title\": \"Error\", \"link\": \"\", \"snippet\": str(e), \"content\": \"\"}]))\n\n        if not response.text or \"text/html\" not in response.headers.get(\"content-type\", \"\").lower():\n            self.status = \"No results found\"\n            return DataFrame(\n                pd.DataFrame([{\"title\": \"Error\", \"link\": \"\", \"snippet\": \"No results found\", \"content\": \"\"}])\n            )\n        soup = BeautifulSoup(response.text, \"html.parser\")\n        results = []\n\n        for result in soup.select(\"div.result\"):\n            title_tag = result.select_one(\"a.result__a\")\n            snippet_tag = result.select_one(\"a.result__snippet\")\n            if title_tag:\n                raw_link = title_tag.get(\"href\", \"\")\n                parsed = urlparse(raw_link)\n                uddg = parse_qs(parsed.query).get(\"uddg\", [\"\"])[0]\n                decoded_link = unquote(uddg) if uddg else raw_link\n\n                try:\n                    final_url = self.ensure_url(decoded_link)\n                    page = requests.get(final_url, headers=headers, timeout=self.timeout)\n                    page.raise_for_status()\n                    content = BeautifulSoup(page.text, \"lxml\").get_text(separator=\" \", strip=True)\n                except requests.RequestException as e:\n                    final_url = decoded_link\n                    content = f\"(Failed to fetch: {e!s}\"\n\n                results.append(\n                    {\n                        \"title\": title_tag.get_text(strip=True),\n                        \"link\": final_url,\n                        \"snippet\": snippet_tag.get_text(strip=True) if snippet_tag else \"\",\n                        \"content\": content,\n                    }\n                )\n\n        df_results = pd.DataFrame(results)\n        return DataFrame(df_results)\n```\n\n## Example 3: RSS Reader Component\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nfrom langflow.custom import Component\nfrom langflow.io import IntInput, MessageTextInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema import DataFrame\n\n\nclass RSSReaderComponent(Component):\n    display_name = \"RSS Reader\"\n    description = \"Fetches and parses an RSS feed.\"\n    icon = \"rss\"\n    name = \"RSSReaderSimple\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"rss_url\",\n            display_name=\"RSS Feed URL\",\n            info=\"URL of the RSS feed to parse.\",\n            tool_mode=True,\n            input_types=[],\n            required=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Timeout for the RSS feed request.\",\n            value=5,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [Output(name=\"articles\", display_name=\"Articles\", method=\"read_rss\")]\n\n    def read_rss(self) -> DataFrame:\n        try:\n            response = requests.get(self.rss_url, timeout=self.timeout)\n            response.raise_for_status()\n            if not response.content.strip():\n                msg = \"Empty response received\"\n                raise ValueError(msg)\n            # Check if the response is valid XML\n            try:\n                BeautifulSoup(response.content, \"xml\")\n            except Exception as e:\n                msg = f\"Invalid XML response: {e}\"\n                raise ValueError(msg) from e\n            soup = BeautifulSoup(response.content, \"xml\")\n            items = soup.find_all(\"item\")\n        except (requests.RequestException, ValueError) as e:\n            self.status = f\"Failed to fetch RSS: {e}\"\n            return DataFrame(pd.DataFrame([{\"title\": \"Error\", \"link\": \"\", \"published\": \"\", \"summary\": str(e)}]))\n\n        articles = [\n            {\n                \"title\": item.title.text if item.title else \"\",\n                \"link\": item.link.text if item.link else \"\",\n                \"published\": item.pubDate.text if item.pubDate else \"\",\n                \"summary\": item.description.text if item.description else \"\",\n            }\n            for item in items\n        ]\n\n        # Ensure the DataFrame has the correct columns even if empty\n        df_articles = pd.DataFrame(articles, columns=[\"title\", \"link\", \"published\", \"summary\"])\n        logger.info(f\"Fetched {len(df_articles)} articles.\")\n        return DataFrame(df_articles)\n```\n\n### Test Implementation for MCP Tools Component\n\n```python\nimport asyncio\nfrom unittest.mock import AsyncMock, MagicMock, patch\n\nimport pytest\nfrom langflow.components.tools.mcp_component import MCPSseClient, MCPStdioClient, MCPToolsComponent\n\nfrom tests.base import ComponentTestBaseWithoutClient, VersionComponentMapping\n\n\nclass TestMCPToolsComponent(ComponentTestBaseWithoutClient):\n    @pytest.fixture\n    def component_class(self):\n        \"\"\"Return the component class to test.\"\"\"\n        return MCPToolsComponent\n\n    @pytest.fixture\n    def default_kwargs(self):\n        \"\"\"Return the default kwargs for the component.\"\"\"\n        return {\n            \"mode\": \"Stdio\",\n            \"command\": \"uvx mcp-server-fetch\",\n            \"sse_url\": \"http://localhost:7860/api/v1/mcp/sse\",\n            \"tool\": \"\",\n        }\n\n    @pytest.fixture\n    def file_names_mapping(self) -> list[VersionComponentMapping]:\n        \"\"\"Return the file names mapping for different versions.\"\"\"\n        return []\n\n    @pytest.fixture\n    def mock_tool(self):\n        \"\"\"Create a mock MCP tool.\"\"\"\n        tool = MagicMock()\n        tool.name = \"test_tool\"\n        tool.description = \"Test tool description\"\n        tool.inputSchema = {\n            \"type\": \"object\",\n            \"properties\": {\"test_param\": {\"type\": \"string\", \"description\": \"Test parameter\"}},\n        }\n        return tool\n\n    @pytest.fixture\n    def mock_stdio_client(self, mock_tool):\n        \"\"\"Create a mock stdio client.\"\"\"\n        stdio_client = AsyncMock()\n        stdio_client.connect_to_server = AsyncMock(return_value=[mock_tool])\n        stdio_client.session = AsyncMock()\n        return stdio_client\n\n    @pytest.fixture\n    def mock_sse_client(self, mock_tool):\n        \"\"\"Create a mock SSE client.\"\"\"\n        sse_client = AsyncMock()\n        sse_client.connect_to_server = AsyncMock(return_value=[mock_tool])\n        sse_client.session = AsyncMock()\n        return sse_client\n\n    async def test_validate_connection_params_invalid_mode(self, component_class, default_kwargs):\n        \"\"\"Test validation with invalid mode.\"\"\"\n        component = component_class(**default_kwargs)\n        with pytest.raises(ValueError, match=\"Invalid mode: invalid. Must be either 'Stdio' or 'SSE'\"):\n            await component._validate_connection_params(\"invalid\")\n\n    async def test_validate_connection_params_missing_command(self, component_class, default_kwargs):\n        \"\"\"Test validation with missing command in Stdio mode.\"\"\"\n        component = component_class(**default_kwargs)\n        with pytest.raises(ValueError, match=\"Command is required for Stdio mode\"):\n            await component._validate_connection_params(\"Stdio\", command=None)\n\n    async def test_validate_connection_params_missing_url(self, component_class, default_kwargs):\n        \"\"\"Test validation with missing URL in SSE mode.\"\"\"\n        component = component_class(**default_kwargs)\n        with pytest.raises(ValueError, match=\"URL is required for SSE mode\"):\n            await component._validate_connection_params(\"SSE\", url=None)\n\n    async def test_update_build_config_mode_change(self, component_class, default_kwargs):\n        \"\"\"Test build config updates when mode changes.\"\"\"\n        component = component_class(**default_kwargs)\n        build_config = {\n            \"command\": {\"show\": False, \"value\": \"uvx mcp-server-fetch\"},\n            \"sse_url\": {\"show\": True, \"value\": \"http://localhost:7860/api/v1/mcp/sse\"},\n            \"tool\": {\"options\": [], \"show\": True},\n            \"mode\": {\"value\": \"Stdio\"},\n            \"env\": {\"show\": True, \"value\": []},\n            \"headers_input\": {\"show\": False, \"value\": []},\n        }\n\n        # Test switching to Stdio mode\n        updated_config = await component.update_build_config(build_config, \"Stdio\", \"mode\")\n        assert updated_config[\"command\"][\"show\"] is True\n        assert updated_config[\"sse_url\"][\"show\"] is False\n\n        # Test switching to SSE mode\n        updated_config = await component.update_build_config(build_config, \"SSE\", \"mode\")\n        assert updated_config[\"command\"][\"show\"] is False\n        assert updated_config[\"sse_url\"][\"show\"] is True\n\n        # Test tool options are updated\n        assert \"options\" in updated_config[\"tool\"]\n\n    @patch(\"langflow.components.tools.mcp_component.create_tool_coroutine\")\n    async def test_build_output(self, mock_create_coroutine, component_class, default_kwargs, mock_tool):\n        \"\"\"Test building output with a tool.\"\"\"\n        component = component_class(**default_kwargs)\n        component.tool = \"test_tool\"\n        component.tools = [mock_tool]\n\n        # Mock the coroutine response\n        mock_response = AsyncMock()\n        mock_content_item = MagicMock()\n        mock_content_item.text = \"Test response\"\n        mock_content_item.model_dump.return_value = {\"text\": \"Test response\"}\n        mock_response.content = [mock_content_item]\n        mock_create_coroutine.return_value = AsyncMock(return_value=mock_response)\n\n        # Create a mock tool and add it to the cache\n        mock_structured_tool = MagicMock()\n        mock_structured_tool.coroutine = mock_create_coroutine.return_value\n        component._tool_cache = {\"test_tool\": mock_structured_tool}\n\n        # Set the test parameter value\n        component.test_param = \"test value\"\n\n        # Mock get_inputs_for_all_tools to return our mock input\n        mock_input = MagicMock()\n        mock_input.name = \"test_param\"\n        with patch.object(component, \"get_inputs_for_all_tools\") as mock_get_inputs:\n            mock_get_inputs.return_value = {\"test_tool\": [mock_input]}\n            output = await component.build_output()\n\n            # Use iloc to access the first row's 'text' column value\n            assert output.iloc[0][\"text\"] == \"Test response\"\n            # Verify the mocks were called correctly\n            mock_get_inputs.assert_called_once_with(component.tools)\n            mock_structured_tool.coroutine.assert_called_once_with(test_param=\"test value\")\n\n    async def test_get_inputs_for_all_tools(self, component_class, default_kwargs, mock_tool):\n        \"\"\"Test getting input schemas for all tools.\"\"\"\n        component = component_class(**default_kwargs)\n        inputs = component.get_inputs_for_all_tools([mock_tool])\n\n        assert \"test_tool\" in inputs\n        assert len(inputs[\"test_tool\"]) > 0  # Should have at least one input parameter\n\n    async def test_remove_non_default_keys(self, component_class, default_kwargs):\n        \"\"\"Test removing non-default keys from build config.\"\"\"\n        component = component_class(**default_kwargs)\n        build_config = {\"code\": {}, \"mode\": {}, \"command\": {}, \"custom_key\": {}}\n\n        component.remove_non_default_keys(build_config)\n        assert \"custom_key\" not in build_config\n        assert all(key in build_config for key in [\"code\", \"mode\", \"command\"])\n\n\nclass TestMCPStdioClient:\n    @pytest.fixture\n    def stdio_client(self):\n        return MCPStdioClient()\n\n    async def test_connect_to_server(self, stdio_client):\n        \"\"\"Test connecting to server via Stdio.\"\"\"\n        # Create mock for stdio transport\n        mock_stdio = AsyncMock()\n        mock_write = AsyncMock()\n        mock_stdio_transport = (mock_stdio, mock_write)\n        mock_stdio_cm = AsyncMock()\n        mock_stdio_cm.__aenter__.return_value = mock_stdio_transport\n\n        # Mock the stdio_client function to return our mock context manager\n        with patch(\"mcp.client.stdio.stdio_client\", return_value=mock_stdio_cm):\n            # Mock ClientSession\n            mock_session = AsyncMock()\n            mock_session.initialize = AsyncMock()\n            mock_session.list_tools.return_value.tools = [MagicMock()]\n\n            # Mock the AsyncExitStack\n            mock_exit_stack = AsyncMock()\n            mock_exit_stack.enter_async_context = AsyncMock()\n            mock_exit_stack.enter_async_context.side_effect = [\n                mock_stdio_transport,  # For stdio_client\n                mock_session,  # For ClientSession\n            ]\n            stdio_client.exit_stack = mock_exit_stack\n\n            tools = await stdio_client.connect_to_server(\"test_command\")\n\n            assert len(tools) == 1\n            assert stdio_client.session is not None\n            # Verify the exit stack was used correctly\n            assert mock_exit_stack.enter_async_context.call_count == 2\n            # Verify the stdio transport was properly set\n            assert stdio_client.stdio == mock_stdio\n            assert stdio_client.write == mock_write\n\n\nclass TestMCPSseClient:\n    @pytest.fixture\n    def sse_client(self):\n        return MCPSseClient()\n\n    async def test_pre_check_redirect(self, sse_client):\n        \"\"\"Test pre-checking URL for redirects.\"\"\"\n        test_url = \"http://test.url\"\n        redirect_url = \"http://redirect.url\"\n\n        with patch(\"httpx.AsyncClient\") as mock_client:\n            mock_response = MagicMock()\n            mock_response.status_code = 307\n            mock_response.headers.get.return_value = redirect_url\n            mock_client.return_value.__aenter__.return_value.request.return_value = mock_response\n\n            result = await sse_client.pre_check_redirect(test_url)\n            assert result == redirect_url\n\n    async def test_connect_to_server(self, sse_client):\n        \"\"\"Test connecting to server via SSE.\"\"\"\n        # Mock the pre_check_redirect first\n        with (\n            patch.object(sse_client, \"pre_check_redirect\", return_value=\"http://test.url\"),\n            patch.object(sse_client, \"validate_url\", return_value=(True, \"\")),\n        ):\n            # Create mock for sse_client context manager\n            mock_sse = AsyncMock()\n            mock_write = AsyncMock()\n            mock_sse_transport = (mock_sse, mock_write)\n            mock_sse_cm = AsyncMock()\n            mock_sse_cm.__aenter__.return_value = mock_sse_transport\n\n            # Mock the sse_client function to return our mock context manager\n            with patch(\"mcp.client.sse.sse_client\", return_value=mock_sse_cm):\n                # Mock ClientSession\n                mock_session = AsyncMock()\n                mock_session.initialize = AsyncMock()\n                mock_session.list_tools.return_value.tools = [MagicMock()]\n\n                # Mock the AsyncExitStack\n                mock_exit_stack = AsyncMock()\n                mock_exit_stack.enter_async_context = AsyncMock()\n                mock_exit_stack.enter_async_context.side_effect = [\n                    mock_sse_transport,  # For sse_client\n                    mock_session,  # For ClientSession\n                ]\n                sse_client.exit_stack = mock_exit_stack\n\n                tools = await sse_client.connect_to_server(\"http://test.url\", {})\n\n                assert len(tools) == 1\n                assert sse_client.session is not None\n                # Verify the exit stack was used correctly\n                assert mock_exit_stack.enter_async_context.call_count == 2\n                # Verify the SSE transport was properly set\n                assert sse_client.sse == mock_sse\n                assert sse_client.write == mock_write\n\n    async def test_connect_timeout(self, sse_client):\n        \"\"\"Test connection timeout handling.\"\"\"\n        # Set max_retries to 1 to avoid multiple retry attempts\n        sse_client.max_retries = 1\n\n        with (\n            patch.object(sse_client, \"pre_check_redirect\", return_value=\"http://test.url\"),\n            patch.object(sse_client, \"validate_url\", return_value=(True, \"\")),  # Mock URL validation\n            patch.object(sse_client, \"_connect_with_timeout\") as mock_connect,\n        ):\n            mock_connect.side_effect = asyncio.TimeoutError()\n\n            # Expect ConnectionError instead of TimeoutError\n            with pytest.raises(\n                ConnectionError,\n                match=(\n                    \"Failed to connect after 1 attempts. \"\n                    \"Last error: Connection to http://test.url timed out after 1 seconds\"\n                ),\n            ):\n                await sse_client.connect_to_server(\"http://test.url\", {}, timeout_seconds=1)\n```\n\n## Development Workflow Example\n\n### Step 1: Create a feature branch\n\n```python\n# First check the current git status\ngit_status = functions.git_status()\nprint(f\"Current git status: {git_status}\")\n\n# Create and checkout a new branch for the component\nfunctions.git_branch(new_branch=\"feature/mcp-tools-component\")\nfunctions.git_checkout(branch_name=\"feature/mcp-tools-component\")\n```\n\n### Step 2: Implementation\n\n```python\n# Create the component file - CRITICAL: Use correct path structure  \nfunctions.create_file(\n    path=\"src/backend/base/langflow/components/tools/mcp_component.py\",\n    file_text=\"\"\"\n# Component code as shown above\n\"\"\"\n)\n\n# Commit the component implementation\nfunctions.git_add(paths=[\"src/backend/base/langflow/components/tools/mcp_component.py\"])\nfunctions.git_commit(message=\"Add MCPToolsComponent with dynamic tool loading\")\n```\n\n### Step 3: Create tests\n\n```python\n# Create the test file - CRITICAL: Use correct path structure\nfunctions.create_file(\n    path=\"src/backend/tests/unit/components/tools/test_mcp_component.py\",\n    file_text=\"\"\"\n# Test code as shown above\n\"\"\"\n)\n\n# Commit the test implementation\nfunctions.git_add(paths=[\"src/backend/tests/unit/components/tools/test_mcp_component.py\"])\nfunctions.git_commit(message=\"Add comprehensive tests for MCPToolsComponent\")\n```\n\n### Step 4: Run tests and fix issues\n\n```python\n# Start a shell session\nsession_id = functions.start_shell_session()\n\n# Run the tests - CRITICAL: Use exact command format\nfunctions.run_command(\n    session_id=session_id,\n    command=\"uv run pytest src/backend/tests/unit/components/tools/test_mcp_component.py -v\"\n)\n\n# Get the test results\ntest_output = functions.get_session_output(session_id=session_id)\nprint(test_output)\n\n# Fix any issues found in tests\n# ...make necessary edits...\nfunctions.git_add(paths=[\"src/backend/base/langflow/components/tools/mcp_component.py\"])\nfunctions.git_commit(message=\"Fix async validation issues in MCPToolsComponent\")\n\n# Run tests again to confirm fixes - Use same exact command\nfunctions.run_command(\n    session_id=session_id,\n    command=\"uv run pytest src/backend/tests/unit/components/tools/test_mcp_component.py -v\"\n)\n\n# Close the shell session\nfunctions.close_shell_session(session_id=session_id)\n```\n\nThese examples showcase advanced component development patterns including:\n- **Dynamic UI Configuration**: The MCP component dynamically shows/hides fields based on mode selection\n- **Async Operations**: Proper async/await patterns for external connections\n- **Complex Input Types**: TableInput, TabInput, and DropdownInput for sophisticated UIs\n- **Error Handling**: Comprehensive exception handling with user-friendly messages\n- **Caching**: Tool caching for performance optimization\n- **External Dependencies**: Integration with external services and libraries\n- **Advanced Validation**: URL validation, input sanitization, and schema validation\n\n## Example 2: RSS Reader Component\n\n```python\nimport pandas as pd\nimport requests\nfrom bs4 import BeautifulSoup\n\nfrom langflow.custom import Component\nfrom langflow.io import IntInput, MessageTextInput, Output\nfrom langflow.logging import logger\nfrom langflow.schema import DataFrame\n\n\nclass RSSReaderComponent(Component):\n    display_name = \"RSS Reader\"\n    description = \"Fetches and parses an RSS feed.\"\n    icon = \"rss\"\n    name = \"RSSReaderSimple\"\n\n    inputs = [\n        MessageTextInput(\n            name=\"rss_url\",\n            display_name=\"RSS Feed URL\",\n            info=\"URL of the RSS feed to parse.\",\n            tool_mode=True,\n            input_types=[],\n            required=True,\n        ),\n        IntInput(\n            name=\"timeout\",\n            display_name=\"Timeout\",\n            info=\"Timeout for the RSS feed request.\",\n            value=5,\n            advanced=True,\n        ),\n    ]\n\n    outputs = [Output(name=\"articles\", display_name=\"Articles\", method=\"read_rss\")]\n\n    def read_rss(self) -> DataFrame:\n        try:\n            response = requests.get(self.rss_url, timeout=self.timeout)\n            response.raise_for_status()\n            if not response.content.strip():\n                msg = \"Empty response received\"\n                raise ValueError(msg)\n            # Check if the response is valid XML\n            try:\n                BeautifulSoup(response.content, \"xml\")\n            except Exception as e:\n                msg = f\"Invalid XML response: {e}\"\n                raise ValueError(msg) from e\n            soup = BeautifulSoup(response.content, \"xml\")\n            items = soup.find_all(\"item\")\n        except (requests.RequestException, ValueError) as e:\n            self.status = f\"Failed to fetch RSS: {e}\"\n            return DataFrame(pd.DataFrame([{\"title\": \"Error\", \"link\": \"\", \"published\": \"\", \"summary\": str(e)}]))\n\n        articles = [\n            {\n                \"title\": item.title.text if item.title else \"\",\n                \"link\": item.link.text if item.link else \"\",\n                \"published\": item.pubDate.text if item.pubDate else \"\",\n                \"summary\": item.description.text if item.description else \"\",\n            }\n            for item in items\n        ]\n\n        # Ensure the DataFrame has the correct columns even if empty\n        df_articles = pd.DataFrame(articles, columns=[\"title\", \"link\", \"published\", \"summary\"])\n        logger.info(f\"Fetched {len(df_articles)} articles.\")\n        return DataFrame(df_articles)\n```\n\n# Complete Conversation Example\n\n## Example 1: Creating a New Data Validation Component with Tests\n\n### User Request\n```\nI need a component that validates CSV data based on custom rules. It should check for missing values, validate data types, and flag rows with issues. Can you create this for me?\n```\n\n### Agent Response\n```\nI'll help you create a CSV Data Validator component with proper tests. First, let me gather the key requirements:\n\n1. Component Name: CSV Data Validator\n2. Description: Validates CSV data against custom rules including missing values, data types, and custom validation\n3. Inputs:\n   - CSV data (DataFrame input)\n   - Validation rules (could be a dictionary or structured input)\n   - Severity threshold (how strict the validation should be)\n4. Outputs:\n   - Validation report (DataFrame)\n   - Valid data (DataFrame with only valid rows)\n   - Invalid data (DataFrame with only invalid rows)\n5. Category: This would fit under the \"Data Processing\" category\n6. Icon: I suggest using \"check-square\" from Lucide icons\n\nBefore I start, I'll set up a Git feature branch for this development:\n\n[Functions.git_status would be used here to check the repo status]\n[Functions.git_branch would be used to create a new branch]\n[Functions.git_checkout would be used to switch to the new branch]\n\nLet me check the existing codebase to understand patterns and find similar components.\n\n[Functions.view_file and functions.find_code_structure would be used here to explore the codebase]\n\nBased on my exploration, I'll create a new component that follows the established patterns. Here's my implementation plan:\n\n1. Create a new file in the appropriate category directory\n2. Define the component class with proper metadata\n3. Implement the validation logic with configurable rules\n4. Add comprehensive error handling\n5. Create tests for the component in the correct location\n6. Run tests to validate functionality\n\nLet me implement this component now:\n\n[Functions.create_file would be used here with the complete component code]\n[Functions.git_add and functions.git_commit would stage and commit the component]\n\nNow I'll create the tests for this component in the correct location:\n\n[Functions.create_file would create test file at: src/backend/tests/unit/components/data/test_csv_data_validator.py]\n[Functions.git_add and functions.git_commit would stage and commit the tests]\n\nLet's run the tests to make sure everything works as expected:\n\n[Functions.start_shell_session would create a shell session]\n[Functions.run_command would run: \"uv run pytest src/backend/tests/unit/components/data/test_csv_data_validator.py -v\"]\n[Functions.get_session_output would check the test results]\n\nI see we need to fix a few issues in the implementation:\n\n[Functions.edit_text would be used to fix the issues]\n[Functions.git_add and functions.git_commit would commit the fixes]\n\nLet's run the tests again to confirm our fixes:\n\n[Functions.run_command would run the same test command again]\n[Functions.get_session_output would show all tests passing]\n\nGreat! The component is now fully implemented, tested, and ready to use. Here's a summary of what I've done:\n\n- âœ“ Created a CSV Data Validator component\n- âœ“ Added proper input validation and error handling\n- âœ“ Implemented configurable validation rules\n- âœ“ Created comprehensive tests in the correct location: src/backend/tests/unit/components/data/test_csv_data_validator.py\n- âœ“ Fixed all issues and verified tests are passing using: uv run pytest src/backend/tests/unit/components/data/test_csv_data_validator.py -v\n- âœ“ Committed all changes to the feature branch\n\nWould you like me to explain any specific part of the implementation or tests?\n```\n\n## Example 2: Modifying an Existing Component with Test Updates\n\n### User Request\n```\nThe TextSplitter component needs to be updated to support custom delimiters and add an option to keep or remove empty strings. Can you update it?\n```\n\n### Agent Response\n```\nI'll help you update the TextSplitter component to add support for custom delimiters and an option to keep or remove empty strings. Let me first set up a feature branch and examine the current implementation.\n\n[Functions.git_status would check the repo status]\n[Functions.git_branch would create a new branch: fix/text-splitter-enhancements]\n[Functions.git_checkout would switch to the new branch]\n\n[Functions.view_file would be used here to see the current TextSplitter component]\n[Functions.view_file would also examine existing tests for the component]\n\nNow that I understand the current implementation, here's my plan for modifying it:\n\n1. Add a new BoolInput for \"keep_empty\" to control whether empty strings are kept\n2. Add a new input for custom delimiters alongside the existing pattern\n3. Update the _split_text method to handle these new options\n4. Update existing tests and add new tests for the new functionality\n\nLet me make these changes:\n\n[Functions.edit_text would be used here with precise context targeting to update the component]\n[Functions.git_add and functions.git_commit would commit the component changes]\n\nNow I'll update the test file to include tests for the new functionality:\n\n[Functions.edit_text would be used to update the test file at: src/backend/tests/unit/components/text/test_text_splitter.py]\n[Functions.git_add and functions.git_commit would commit the test changes]\n\nLet's run the tests to make sure everything works:\n\n[Functions.start_shell_session would create a shell session]\n[Functions.run_command would run: \"uv run pytest src/backend/tests/unit/components/text/test_text_splitter.py -v\"]\n[Functions.get_session_output would check the test results]\n\nLet me fix any issues that the tests revealed:\n\n[Functions.edit_text would fix any issues found]\n[Functions.git_add and functions.git_commit would commit the fixes]\n\nLet's run the tests again to confirm our fixes:\n\n[Functions.run_command would run the same test command again]\n[Functions.get_session_output would show all tests passing]\n\nHere's a summary of the changes I've made:\n\n1. Added a new BoolInput named \"keep_empty\" with these properties:\n   - display_name: \"Keep Empty Strings\"\n   - info: \"If true, empty strings will be kept in the output\"\n   - advanced: True\n   - value: False\n\n2. Added a new StrInput named \"custom_delimiter\":\n   - display_name: \"Custom Delimiter\"\n   - info: \"Custom delimiter to split text (alternative to pattern)\"\n   - advanced: True\n\n3. Modified the _split_text method to:\n   - Check for custom_delimiter first, then fall back to pattern\n   - Apply the keep_empty filter based on the new setting\n   - Add documentation for the new options\n\n4. Updated and added tests to verify:\n   - Custom delimiter functionality works correctly\n   - Empty string filtering works based on the keep_empty setting\n   - Edge cases are handled properly\n\nAll tests are now passing, and the changes maintain backward compatibility while adding the new functionality. Would you like me to explain any specific part of the implementation or tests in more detail?\n```\n\n# Component Creation Checklist\n\nWhen creating or modifying components, follow this checklist:\n\n- [ ] Gather all requirements from the user (name, description, inputs, outputs, category)\n- [ ] Set up a feature branch for version control\n- [ ] Select an appropriate icon (Lucide or custom)\n- [ ] Define the component class with proper metadata\n- [ ] Implement all required inputs with appropriate types and helpful descriptions\n- [ ] Define outputs with clear method references\n- [ ] Implement core logic in methods referenced by outputs\n- [ ] Add robust error handling and logging\n- [ ] Include helpful docstrings and comments\n- [ ] Create comprehensive tests for the component in the correct location:\n  **CRITICAL**: `src/backend/tests/unit/components/{category}/test_{component_name}.py`\n- [ ] If needed, implement dynamic UI with `update_build_config`\n- [ ] Place the component in the correct category folder\n- [ ] Run tests using exact command format:\n  **CRITICAL**: `uv run pytest src/backend/tests/unit/components/{category}/test_{component_name}.py -v`\n- [ ] Fix any issues and re-run tests until all pass\n- [ ] Commit the working implementation with passing tests\n\n# Key Reminders (Critical Instructions)\n\nAs you work on component creation and modification, remember these critical instructions:\n\n1. **Always create a feature branch first** before starting component implementation\n2. **Always explore the codebase first** before making any changes to understand patterns and conventions\n3. **Use file manipulation tools instead of guessing** about file structure or content\n4. **Make incremental, verifiable changes** rather than large, complex edits\n5. **Follow the component development workflow** step-by-step to ensure nothing is missed\n6. **Include robust error handling** in all component methods\n7. **Write comprehensive tests** for all component functionality\n8. **Run tests after each significant change** to catch issues early\n9. **Commit working code frequently** with descriptive commit messages\n10. **Continue working until all tests pass** and the component is fully functional\n11. **Think step-by-step** about what the component needs to do and how to implement it\n12. **Never consider a component complete until tests pass**\n\nRemember to plan thoroughly, use the available tools for precise file manipulation, and verify that all requirements have been met with passing tests before considering the task complete."
              },
              "temperature": {
                "_input_type": "SliderInput",
                "advanced": true,
                "display_name": "Temperature",
                "dynamic": false,
                "info": "",
                "max_label": "",
                "max_label_icon": "",
                "min_label": "",
                "min_label_icon": "",
                "name": "temperature",
                "placeholder": "",
                "range_spec": {
                  "max": 1,
                  "min": 0,
                  "step": 0.01,
                  "step_type": "float"
                },
                "required": false,
                "show": true,
                "slider_buttons": false,
                "slider_buttons_options": [],
                "slider_input": false,
                "title_case": false,
                "tool_mode": false,
                "type": "slider",
                "value": 0.1
              },
              "template": {
                "_input_type": "MultilineInput",
                "advanced": true,
                "copy_field": false,
                "display_name": "Template",
                "dynamic": false,
                "info": "The template to use for formatting the data. It can contain the keys {text}, {sender} or any other key in the message data.",
                "input_types": [
                  "Message"
                ],
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "multiline": true,
                "name": "template",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_input": true,
                "trace_as_metadata": true,
                "type": "str",
                "value": "{sender_name}: {text}"
              },
              "timeout": {
                "_input_type": "IntInput",
                "advanced": true,
                "display_name": "Timeout",
                "dynamic": false,
                "info": "The timeout for requests to OpenAI completion API.",
                "list": false,
                "list_add_label": "Add More",
                "name": "timeout",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "int",
                "value": 700
              },
              "tools": {
                "_input_type": "HandleInput",
                "advanced": false,
                "display_name": "Tools",
                "dynamic": false,
                "info": "These are the tools that the agent can use to help with tasks.",
                "input_types": [
                  "Tool"
                ],
                "list": true,
                "list_add_label": "Add More",
                "name": "tools",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "trace_as_metadata": true,
                "type": "other",
                "value": ""
              },
              "verbose": {
                "_input_type": "BoolInput",
                "advanced": true,
                "display_name": "Verbose",
                "dynamic": false,
                "info": "",
                "list": false,
                "list_add_label": "Add More",
                "name": "verbose",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "Agent"
        },
        "dragging": false,
        "id": "Agent-Oloh8",
        "measured": {
          "height": 699,
          "width": 320
        },
        "position": {
          "x": 1641.6239626366948,
          "y": 301.10345101561927
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "FileManipulation-Z3xCV",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "category": "tools",
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Efficient file and directory operations with content editing capabilities.",
            "display_name": "File Manipulation",
            "documentation": "",
            "edited": false,
            "field_order": [
              "workspace_folder"
            ],
            "frozen": false,
            "icon": "file-text",
            "key": "FileManipulation",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tools",
                "hidden": false,
                "method": "build_toolkit",
                "name": "tools",
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "score": 0.0035156044052829824,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "import os\nimport shutil\nimport platform\nimport re\nimport fnmatch\nimport tempfile\nfrom datetime import datetime\nfrom typing import List, Optional, Tuple, Dict, Any\nfrom enum import Enum\nimport ast\nimport difflib\n\nfrom langflow.custom import Component\nfrom langflow.field_typing import Tool\nfrom langflow.io import StrInput, Output\n\n\nclass BackupManager:\n    \"\"\"Simple backup system for file operations.\"\"\"\n    \n    def __init__(self, workspace_folder: str):\n        self.workspace_folder = workspace_folder\n        self.backup_folder = os.path.join(workspace_folder, \".backups\")\n        self.backup_registry = {}  # file_path -> [backup_ids]\n        self.current_positions = {}  # file_path -> current_position_index\n        \n        if not os.path.exists(self.backup_folder):\n            os.makedirs(self.backup_folder)\n    \n    def backup_file(self, file_path: str) -> Optional[str]:\n        \"\"\"Create a backup of a file before modifying it.\"\"\"\n        if not os.path.exists(file_path):\n            return None\n            \n        timestamp = datetime.now().strftime(\"%Y%m%d_%H%M%S\")\n        file_name = os.path.basename(file_path)\n        backup_id = f\"{file_name}_{timestamp}\"\n        backup_path = os.path.join(self.backup_folder, backup_id)\n        \n        try:\n            shutil.copy2(file_path, backup_path)\n            \n            if file_path not in self.backup_registry:\n                self.backup_registry[file_path] = []\n                self.current_positions[file_path] = -1\n                \n            # If we're not at the end of history, truncate it\n            position = self.current_positions[file_path]\n            if position != -1:\n                self.backup_registry[file_path] = self.backup_registry[file_path][:position+1]\n                self.current_positions[file_path] = -1\n                \n            self.backup_registry[file_path].append(backup_id)\n            return backup_id\n            \n        except Exception as e:\n            return None\n    \n    def get_backups(self, file_path: str) -> List[str]:\n        \"\"\"Get list of backups for a file.\"\"\"\n        return self.backup_registry.get(file_path, [])\n    \n    def get_backup_info(self, file_path: str) -> Dict[str, Any]:\n        \"\"\"Get information about backup history.\"\"\"\n        if file_path not in self.backup_registry:\n            return {\n                \"count\": 0, \n                \"position\": -1, \n                \"can_undo\": False, \n                \"can_redo\": False\n            }\n            \n        backups = self.backup_registry[file_path]\n        position = self.current_positions[file_path]\n        \n        return {\n            \"count\": len(backups),\n            \"position\": position,\n            \"can_undo\": position < len(backups) - 1 if position != -1 else len(backups) > 0,\n            \"can_redo\": position > 0 if position != -1 else False\n        }\n    \n    def restore(self, file_path: str, direction: str = \"undo\") -> Tuple[bool, Optional[str], str]:\n        \"\"\"Restore a file to a previous or newer version.\"\"\"\n        if file_path not in self.backup_registry:\n            return False, None, \"No backup history for this file\"\n            \n        backups = self.backup_registry[file_path]\n        if not backups:\n            return False, None, \"No backups available\"\n            \n        position = self.current_positions[file_path]\n        \n        if direction == \"undo\":\n            if position == -1:\n                new_position = len(backups) - 1\n            elif position > 0:\n                new_position = position - 1\n            else:\n                return False, None, \"No earlier version available\"\n                \n        elif direction == \"redo\":\n            if position == -1:\n                return False, None, \"No redo operations available. You can only redo after an undo operation.\"\n            elif position < len(backups) - 1:\n                new_position = position + 1\n            else:\n                # Already at most recent backup, restore to current version\n                self.current_positions[file_path] = -1\n                return True, \"current\", \"Restored to current version\"\n        else:\n            return False, None, f\"Invalid direction: {direction}\"\n        \n        backup_id = backups[new_position]\n        backup_path = os.path.join(self.backup_folder, backup_id)\n        \n        if not os.path.exists(backup_path):\n            return False, None, f\"Backup file not found: {backup_id}\"\n            \n        try:\n            shutil.copy2(backup_path, file_path)\n            self.current_positions[file_path] = new_position\n            return True, backup_id, f\"Successfully restored {direction} to version {new_position+1} of {len(backups)}\"\n        except Exception as e:\n            return False, None, f\"Failed to restore: {str(e)}\"\n\n\nclass PathHandler:\n    \"\"\"Handle path operations safely.\"\"\"\n    \n    def __init__(self, workspace_folder: str):\n        self.workspace_folder = workspace_folder\n        self.platform = platform.system()\n    \n    def resolve_path(self, relative_path: str, must_exist: bool = True) -> str:\n        \"\"\"Resolve a path relative to the workspace and check security constraints.\"\"\"\n        # Check if absolute\n        if os.path.isabs(relative_path):\n            raise ValueError(f\"Path must be relative to workspace: {relative_path}\")\n            \n        # Normalize path separators for the current platform\n        if self.platform == \"Windows\":\n            relative_path = relative_path.replace('/', '\\\\')\n        else:\n            relative_path = relative_path.replace('\\\\', '/')\n            \n        # Join with workspace and normalize\n        full_path = os.path.normpath(os.path.join(self.workspace_folder, relative_path))\n        \n        # Security check: ensure path is within workspace\n        if not os.path.abspath(full_path).startswith(os.path.abspath(self.workspace_folder)):\n            raise ValueError(f\"Path must be within workspace: {relative_path}\")\n            \n        # Check existence if required\n        if must_exist and not os.path.exists(full_path):\n            raise FileNotFoundError(f\"Path does not exist: {relative_path}\")\n            \n        return full_path\n        \n    def is_within_workspace(self, path: str) -> bool:\n        \"\"\"Check if a path is within the workspace.\"\"\"\n        abs_path = os.path.abspath(path)\n        abs_workspace = os.path.abspath(self.workspace_folder)\n        return abs_path.startswith(abs_workspace)\n    \n    def ensure_directory_exists(self, path: str) -> None:\n        \"\"\"Ensure that the directory for the given path exists.\"\"\"\n        directory = os.path.dirname(path)\n        if not os.path.exists(directory):\n            os.makedirs(directory, exist_ok=True)\n\n\nclass FileEditOperation(Enum):\n    \"\"\"Types of file edit operations.\"\"\"\n    REPLACE = \"replace\"\n    INSERT = \"insert\"\n    REMOVE = \"remove\"\n    MOVE = \"move\"\n\n\nclass FileManipulation(Component):\n    display_name = \"File Manipulation\"\n    description = \"Efficient file and directory operations with content editing capabilities.\"\n    icon = \"file-text\"\n    name = \"FileManipulation\"\n    \n    inputs = [\n        StrInput(\n            name=\"workspace_folder\",\n            display_name=\"Workspace Folder\",\n            info=\"Base directory for all file operations. All paths will be relative to this folder.\",\n            required=True,\n        ),\n    ]\n    \n    outputs = [\n        Output(name=\"tools\", display_name=\"Tools\", method=\"build_toolkit\"),\n    ]\n    \n    def __init__(self, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n        self.backup_manager = None\n        self.path_handler = None\n        \n    def _get_file_preview(self, file_path: str, line_number: Optional[int] = None, context_lines: int = 5) -> str:\n        \"\"\"Get a preview of file content with line numbers.\"\"\"\n        try:\n            resolved_path = self.path_handler.resolve_path(file_path)\n            \n            if not os.path.exists(resolved_path):\n                return f\"File not found: {file_path}\"\n                \n            # Handle empty files\n            if os.path.getsize(resolved_path) == 0:\n                return f\"File is empty: {file_path}\"\n            \n            with open(resolved_path, 'r', encoding='utf-8') as f:\n                lines = f.readlines()\n            \n            # If specific line is provided, show context around it\n            if line_number is not None:\n                start = max(0, line_number - context_lines - 1)\n                end = min(len(lines), line_number + context_lines)\n                preview_lines = lines[start:end]\n                result = \"\"\n                for i, line in enumerate(preview_lines, start=start+1):\n                    prefix = \">>> \" if i == line_number else \"    \"\n                    result += f\"{prefix}{i}: {line}\"\n                return result\n            \n            # Otherwise show first few lines\n            result = \"\"\n            preview_length = min(10, len(lines))\n            for i, line in enumerate(lines[:preview_length], start=1):\n                result += f\"{i}: {line}\"\n            if len(lines) > preview_length:\n                result += f\"\\n... and {len(lines)-preview_length} more lines\"\n            return result\n            \n        except Exception as e:\n            return f\"Error getting file preview: {str(e)}\"\n    \n    def _edit_file(\n        self, \n        path: str, \n        operation: FileEditOperation,\n        search: Optional[str] = None,\n        replacement: Optional[str] = None,\n        line_number: Optional[int] = None,\n        end_line: Optional[int] = None,\n        target_line: Optional[int] = None,\n        use_regex: bool = False,\n        replace_all: bool = False,\n        context_before: Optional[str] = None,\n        context_after: Optional[str] = None,\n        occurrence: int = 1,\n        dry_run: bool = False\n    ) -> str:\n        \"\"\"Unified method for file editing operations.\"\"\"\n        try:\n            resolved_path = self.path_handler.resolve_path(path, must_exist=False)\n            \n            # Check if file exists and create an empty file if needed\n            file_exists = os.path.exists(resolved_path)\n            if not file_exists:\n                if operation == FileEditOperation.INSERT:\n                    # Create parent directories if they don't exist\n                    self.path_handler.ensure_directory_exists(resolved_path)\n                    # Create empty file for insertion\n                    with open(resolved_path, 'w', encoding='utf-8') as f:\n                        pass\n                    file_exists = True\n                else:\n                    return f\"Error: File doesn't exist: {path}. To create a new file, use insert at line 1 or create_file.\"\n            \n            # Backup the file if not in dry run mode and file exists\n            if not dry_run and file_exists:\n                backup_id = self.backup_manager.backup_file(resolved_path)\n            \n            # Read file content if file exists\n            content = \"\"\n            lines = []\n            if file_exists:\n                try:\n                    with open(resolved_path, 'r', encoding='utf-8') as f:\n                        content = f.read()\n                        lines = content.splitlines(keepends=True)\n                except Exception as e:\n                    return f\"Error reading file: {str(e)}\"\n            \n            # Execute the requested operation\n            if operation == FileEditOperation.REPLACE:\n                if not search or replacement is None:\n                    return \"Error: Search and replacement strings are required for replace operation\"\n                    \n                # Special handling for empty files\n                if not content:\n                    return f\"Error: Cannot replace text in empty file {path}. Use insert_at_line instead.\"\n                \n                new_content, locations = self._replace_content(\n                    content, \n                    search, \n                    replacement, \n                    use_regex, \n                    replace_all, \n                    context_before, \n                    context_after, \n                    line_number, \n                    occurrence\n                )\n                \n                if not locations:\n                    pattern_type = \"Regex pattern\" if use_regex else \"Text\"\n                    return f\"Error: {pattern_type} not found in {path}\"\n                    \n            elif operation == FileEditOperation.INSERT:\n                if replacement is None:\n                    return \"Error: Replacement text is required for insert operation\"\n                    \n                # Handle insertion in empty or small files\n                if line_number is None:\n                    line_number = 1\n                \n                # Handle case where line number is beyond file length\n                if line_number > len(lines) + 1:\n                    # For empty files or new files, accept only line 1\n                    if len(lines) == 0 and line_number != 1:\n                        return f\"Error: File is empty. For empty files, you can only insert at line 1.\"\n                    # For non-empty files, allow insert at line = len(lines) + 1 (end of file)\n                    elif line_number > len(lines) + 1:\n                        return f\"Error: Invalid line number {line_number}. File has {len(lines)} lines. Valid range is 1 to {len(lines) + 1}.\"\n                \n                # Convert to 0-based indexing\n                insert_index = max(0, min(line_number - 1, len(lines)))\n                \n                # Insert the new text\n                if not replacement.endswith('\\n'):\n                    replacement += '\\n'\n                    \n                if not lines:\n                    # Empty file case\n                    lines = [replacement]\n                else:\n                    lines.insert(insert_index, replacement)\n                    \n                new_content = ''.join(lines)\n                \n            elif operation == FileEditOperation.REMOVE:\n                if line_number is None or end_line is None:\n                    return \"Error: Start and end line numbers are required for remove operation\"\n                \n                # Special handling for empty files\n                if not lines:\n                    return f\"Warning: Cannot remove lines from empty file {path}.\"\n                    \n                if line_number < 1 or end_line > len(lines) or line_number > end_line:\n                    return f\"Error: Invalid line range. File has {len(lines)} lines, requested to remove lines {line_number}-{end_line}.\"\n                    \n                # Convert to 0-based indexing\n                start_idx = line_number - 1\n                end_idx = end_line\n                \n                # Remove the lines\n                removed_lines = lines[start_idx:end_idx]\n                lines = lines[:start_idx] + lines[end_idx:]\n                new_content = ''.join(lines)\n                \n            elif operation == FileEditOperation.MOVE:\n                if line_number is None or end_line is None or target_line is None:\n                    return \"Error: Start, end, and target line numbers are required for move operation\"\n                \n                # Special handling for empty files\n                if not lines:\n                    return f\"Warning: Cannot move lines in empty file {path}.\"\n                    \n                if line_number < 1 or end_line > len(lines) or line_number > end_line:\n                    return f\"Error: Invalid line range. File has {len(lines)} lines, requested to move lines {line_number}-{end_line}.\"\n                    \n                if target_line < 1 or target_line > len(lines) + 1:\n                    return f\"Error: Invalid target line. File has {len(lines)} lines, requested to insert at line {target_line}.\"\n                    \n                # Check if target is within the block to move\n                if target_line >= line_number and target_line <= end_line + 1:\n                    return \"Error: Target line is within the block to move. This would result in no change.\"\n                    \n                # Convert to 0-based indexing\n                start_idx = line_number - 1\n                end_idx = end_line\n                target_idx = target_line - 1\n                \n                # Extract the block to move\n                block_lines = lines[start_idx:end_idx]\n                \n                # Adjust target position if it's after the block being removed\n                adjusted_target = target_idx\n                if target_idx > end_idx:\n                    adjusted_target -= (end_idx - start_idx)\n                \n                # Build the new content\n                new_lines = []\n                i = 0\n                while i < len(lines):\n                    if i == start_idx:\n                        # Skip the block being moved\n                        i = end_idx\n                    elif i == adjusted_target:\n                        # Insert the block at the target position\n                        new_lines.extend(block_lines)\n                        if i < len(lines):\n                            new_lines.append(lines[i])\n                        i += 1\n                    else:\n                        if i < len(lines):\n                            new_lines.append(lines[i])\n                        i += 1\n                \n                # Handle case when target is at the end of the file\n                if adjusted_target == len(lines):\n                    new_lines.extend(block_lines)\n                    \n                new_content = ''.join(new_lines)\n            \n            else:\n                return f\"Error: Unsupported operation: {operation}\"\n            \n            # Write the changes if not a dry run\n            if not dry_run:\n                # Ensure parent directory exists\n                self.path_handler.ensure_directory_exists(resolved_path)\n                \n                with open(resolved_path, 'w', encoding='utf-8') as f:\n                    f.write(new_content)\n            \n            # Generate result message\n            action = \"Would \" if dry_run else \"\"\n            \n            if operation == FileEditOperation.REPLACE:\n                replaced_count = len(locations)\n                msg = f\"{action}replace{'d' if not dry_run else ''} {replaced_count} {'regex match' if use_regex else 'location'}{'es' if replaced_count > 1 else ''} in {path}.\"\n                preview_line = locations[0][2] if locations else None\n                \n            elif operation == FileEditOperation.INSERT:\n                msg = f\"{action}insert{'ed' if not dry_run else ''} text at line {line_number} in {path}.\"\n                preview_line = line_number\n                \n            elif operation == FileEditOperation.REMOVE:\n                lines_removed = end_line - line_number + 1\n                msg = f\"{action}remove{'d' if not dry_run else ''} {lines_removed} line{'s' if lines_removed != 1 else ''} ({line_number}-{end_line}) from {path}.\"\n                preview_line = max(1, line_number - 1)\n                \n            elif operation == FileEditOperation.MOVE:\n                lines_moved = end_line - line_number + 1\n                msg = f\"{action}move{'d' if not dry_run else ''} {lines_moved} line{'s' if lines_moved != 1 else ''} from {line_number}-{end_line} to line {target_line} in {path}.\"\n                preview_line = max(1, target_line - 2) if target_line < line_number else max(1, target_line - lines_moved - 2)\n            \n            # Get file preview after the change\n            file_preview = self._get_file_preview(path, preview_line)\n            return f\"{msg}\\n\\nPreview:\\n{file_preview}\"\n            \n        except Exception as e:\n            return f\"Error editing file: {str(e)}\"\n    \n    def _replace_content(\n        self, \n        content: str, \n        search: str, \n        replacement: str, \n        use_regex: bool, \n        replace_all: bool, \n        context_before: Optional[str], \n        context_after: Optional[str], \n        line_number: Optional[int], \n        occurrence: int\n    ) -> Tuple[str, List[Tuple[int, int, int]]]:\n        \"\"\"Find and replace content with various targeting options.\"\"\"\n        lines = content.split('\\n')\n        occurrences = []\n        \n        if use_regex:\n            # Regex-based search\n            try:\n                regex = re.compile(search, re.MULTILINE | re.DOTALL)\n            except re.error as e:\n                # Handle invalid regex pattern\n                msg = f\"Invalid regex pattern: {str(e)}\"\n                raise ValueError(msg)\n                \n            # Handle line number constraint\n            if line_number is not None:\n                line_idx = line_number - 1\n                if 0 <= line_idx < len(lines):\n                    line_content = lines[line_idx]\n                    for match in regex.finditer(line_content):\n                        line_start = sum(len(lines[i]) + 1 for i in range(line_idx))\n                        start = line_start + match.start()\n                        end = line_start + match.end()\n                        occurrences.append((start, end, line_number))\n            else:\n                for match in regex.finditer(content):\n                    start, end = match.span()\n                    line_count = content[:start].count('\\n') + 1\n                    occurrences.append((start, end, line_count))\n                    \n        else:\n            # Plain string search\n            if context_before or context_after:\n                # Context-aware search\n                import re\n                try:\n                    if context_before and context_after:\n                        pattern_str = f\"(?<={re.escape(context_before)})({re.escape(search)})(?={re.escape(context_after)})\"\n                    elif context_before:\n                        pattern_str = f\"(?<={re.escape(context_before)})({re.escape(search)})\"\n                    elif context_after:\n                        pattern_str = f\"({re.escape(search)})(?={re.escape(context_after)})\"\n                        \n                    pattern = re.compile(pattern_str, re.MULTILINE | re.DOTALL)\n                    matches = list(pattern.finditer(content))\n                    \n                    for match in matches:\n                        start, end = match.span(1)\n                        line_count = content[:start].count('\\n') + 1\n                        occurrences.append((start, end, line_count))\n                except re.error:\n                    # Fall back to regular search if context pattern is invalid\n                    pass\n                    \n            elif line_number is not None:\n                # Line-constrained search\n                line_idx = line_number - 1\n                if 0 <= line_idx < len(lines):\n                    line_content = lines[line_idx]\n                    start_pos = 0\n                    while True:\n                        pos = line_content.find(search, start_pos)\n                        if pos == -1:\n                            break\n                        line_start = sum(len(lines[i]) + 1 for i in range(line_idx))\n                        start = line_start + pos\n                        end = start + len(search)\n                        occurrences.append((start, end, line_number))\n                        start_pos = pos + 1\n            else:\n                # Full-content search\n                start_pos = 0\n                while True:\n                    pos = content.find(search, start_pos)\n                    if pos == -1:\n                        break\n                    line_count = content[:pos].count('\\n') + 1\n                    occurrences.append((pos, pos + len(search), line_count))\n                    start_pos = pos + 1\n        \n        if not occurrences:\n            return content, []\n            \n        # Sort occurrences by position\n        occurrences.sort()\n        \n        # Select which occurrences to replace\n        if replace_all:\n            to_replace = occurrences\n        else:\n            # Validate occurrence index\n            if occurrence < 1 or occurrence > len(occurrences):\n                valid_range = f\"1 to {len(occurrences)}\"\n                msg = f\"Invalid occurrence index {occurrence}. Valid range is {valid_range}.\"\n                to_replace = []\n            else:\n                to_replace = [occurrences[occurrence-1]]\n        \n        if not to_replace:\n            return content, []\n            \n        # Apply replacements\n        new_content = content\n        for pos_start, pos_end, line_num in reversed(to_replace):\n            if use_regex:\n                match_text = content[pos_start:pos_end]\n                try:\n                    replaced_text = re.sub(search, replacement, match_text)\n                    new_content = new_content[:pos_start] + replaced_text + new_content[pos_end:]\n                except Exception:\n                    # Skip invalid regex replacements\n                    pass\n            else:\n                new_content = new_content[:pos_start] + replacement + new_content[pos_end:]\n                \n        return new_content, to_replace\n    \n    def build_toolkit(self) -> Tool:\n        \"\"\"Build and return file system tools.\"\"\"\n        # Initialize components\n        self.backup_manager = BackupManager(self.workspace_folder)\n        self.path_handler = PathHandler(self.workspace_folder)\n        \n        from langchain_core.tools import tool\n        \n        @tool\n        def view_file(path: str, view_range: Optional[List[int]] = None) -> str:\n            \"\"\"View file contents with line numbers.\n            \n            Args:\n                path: Path to the file relative to workspace\n                view_range: Optional [start_line, end_line] to view specific lines (use -1 for end of file)\n                \n            Returns:\n                File contents with line numbers\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path)\n                \n                # Check if file is empty\n                if os.path.getsize(resolved_path) == 0:\n                    return f\"File is empty: {path}\"\n                \n                with open(resolved_path, 'r', encoding='utf-8') as f:\n                    lines = f.readlines()\n                \n                # Process view range if provided\n                if view_range and len(view_range) == 2:\n                    start = max(0, view_range[0] - 1)  # Convert to 0-indexed\n                    end = len(lines) if view_range[1] == -1 else view_range[1]\n                    lines = lines[start:end]\n                    \n                    # Add line numbers\n                    result = \"\"\n                    for i, line in enumerate(lines):\n                        line_num = view_range[0] + i\n                        result += f\"{line_num}: {line}\"\n                    \n                    return result\n                \n                # Otherwise show the whole file with line numbers\n                result = \"\"\n                for i, line in enumerate(lines, start=1):\n                    result += f\"{i}: {line}\"\n                \n                return result\n            \n            except FileNotFoundError:\n                return f\"Error: File not found: {path}\"\n            except Exception as e:\n                return f\"Error viewing file: {str(e)}\"\n        \n        @tool\n        def edit_text(\n            path: str, \n            old_str: str, \n            new_str: str, \n            use_regex: bool = False,\n            replace_all: bool = False,\n            context_before: Optional[str] = None,\n            context_after: Optional[str] = None,\n            line_number: Optional[int] = None,\n            occurrence: int = 1,\n            dry_run: bool = False\n        ) -> str:\n            \"\"\"Replace text in a file with enhanced targeting options.\n            \n            Args:\n                path: Path to the file relative to workspace\n                old_str: Text or regex pattern to search for\n                new_str: Text to replace with\n                use_regex: Whether to interpret old_str as a regular expression\n                replace_all: If True, replace all occurrences\n                context_before: Text that must appear before the replacement\n                context_after: Text that must appear after the replacement\n                line_number: Line number to narrow search\n                occurrence: Which occurrence to replace (1-based, ignored if replace_all=True)\n                dry_run: If True, only show what would change without making changes\n                \n            Returns:\n                Result of the operation with preview of changed content\n            \"\"\"\n            return self._edit_file(\n                path=path,\n                operation=FileEditOperation.REPLACE,\n                search=old_str,\n                replacement=new_str,\n                use_regex=use_regex,\n                replace_all=replace_all,\n                context_before=context_before,\n                context_after=context_after,\n                line_number=line_number,\n                occurrence=occurrence,\n                dry_run=dry_run\n            )\n        \n        @tool\n        def insert_at_line(path: str, line_number: int, new_str: str, dry_run: bool = False) -> str:\n            \"\"\"Insert text at a specific line number in a file.\n            \n            Args:\n                path: Path to the file relative to workspace\n                line_number: Line number where to insert text (1-based). For empty files, use line 1.\n                new_str: Text to insert\n                dry_run: If True, only show what would change without making changes\n                \n            Returns:\n                Result of the operation with preview of changed content\n            \"\"\"\n            return self._edit_file(\n                path=path,\n                operation=FileEditOperation.INSERT,\n                replacement=new_str,\n                line_number=line_number,\n                dry_run=dry_run\n            )\n        \n        @tool\n        def remove_lines(path: str, start_line: int, end_line: int, dry_run: bool = False) -> str:\n            \"\"\"Remove a range of lines from a file.\n            \n            Args:\n                path: Path to the file relative to workspace\n                start_line: First line to remove (1-based)\n                end_line: Last line to remove (1-based)\n                dry_run: If True, only show what would change without making changes\n                \n            Returns:\n                Result of the operation with preview\n            \"\"\"\n            return self._edit_file(\n                path=path,\n                operation=FileEditOperation.REMOVE,\n                line_number=start_line,\n                end_line=end_line,\n                dry_run=dry_run\n            )\n        \n        @tool\n        def move_code_block(path: str, start_line: int, end_line: int, target_line: int, dry_run: bool = False) -> str:\n            \"\"\"Move a block of code from one location to another in the same file.\n            \n            Args:\n                path: Path to the file relative to workspace\n                start_line: First line of block to move (1-based)\n                end_line: Last line of block to move (1-based)\n                target_line: Line number where to insert the block (1-based)\n                dry_run: If True, only show what would change without making changes\n                \n            Returns:\n                Result of the operation with preview\n            \"\"\"\n            return self._edit_file(\n                path=path,\n                operation=FileEditOperation.MOVE,\n                line_number=start_line,\n                end_line=end_line,\n                target_line=target_line,\n                dry_run=dry_run\n            )\n        \n        @tool\n        def undo_edit(path: str) -> str:\n            \"\"\"Undo the last edit made to a file.\n            \n            Args:\n                path: Path to the file relative to workspace\n                \n            Returns:\n                Result of the operation with preview of the previous version\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path)\n                success, backup_id, message = self.backup_manager.restore(resolved_path, \"undo\")\n                \n                if not success:\n                    return f\"Note: {message}\"\n                    \n                # Get information about backup history\n                info = self.backup_manager.get_backup_info(resolved_path)\n                \n                # Get preview\n                file_preview = self._get_file_preview(path)\n                \n                result = f\"Successfully undid changes to {path}.\\n\"\n                if info[\"position\"] >= 0:\n                    result += f\"Restored to version {info['position']+1} of {info['count']}.\\n\"\n                    if info[\"can_undo\"]:\n                        result += f\"You can undo {info['count'] - info['position'] - 1} more time(s).\\n\"\n                    if info[\"can_redo\"]:\n                        result += \"You can redo this operation.\\n\"\n                \n                result += f\"\\nPreview:\\n{file_preview}\"\n                return result\n                \n            except Exception as e:\n                return f\"Error undoing edit: {str(e)}\"\n        \n        @tool\n        def redo_edit(path: str) -> str:\n            \"\"\"Redo a previously undone edit to a file.\n            \n            Args:\n                path: Path to the file relative to workspace\n                \n            Returns:\n                Result of the operation with preview of the newer version\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path)\n                success, backup_id, message = self.backup_manager.restore(resolved_path, \"redo\")\n                \n                if not success:\n                    return f\"Note: {message}\"\n                    \n                # Get information about backup history\n                info = self.backup_manager.get_backup_info(resolved_path)\n                \n                # Get preview\n                file_preview = self._get_file_preview(path)\n                \n                result = f\"Successfully redid changes to {path}.\\n\"\n                if backup_id == \"current\":\n                    result += \"Restored to current version.\\n\"\n                    if info[\"can_undo\"]:\n                        result += \"You can undo this operation.\\n\"\n                elif info[\"position\"] >= 0:\n                    result += f\"Restored to version {info['position']+1} of {info['count']}.\\n\"\n                    if info[\"can_undo\"]:\n                        result += \"You can undo this operation.\\n\"\n                    if info[\"can_redo\"]:\n                        result += f\"You can redo {info['position']} more time(s).\\n\"\n                \n                result += f\"\\nPreview:\\n{file_preview}\"\n                return result\n                \n            except Exception as e:\n                return f\"Error redoing edit: {str(e)}\"\n        \n        @tool\n        def create_file(path: str, file_text: str) -> str:\n            \"\"\"Create a new file with content.\n            \n            Args:\n                path: Path to the file relative to workspace\n                file_text: Text content to write to the file\n                \n            Returns:\n                Result of the operation with preview\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path, must_exist=False)\n                \n                # Create directories if they don't exist\n                os.makedirs(os.path.dirname(os.path.abspath(resolved_path)), exist_ok=True)\n                \n                # Check if file exists\n                action = \"Created\"\n                if os.path.exists(resolved_path):\n                    self.backup_manager.backup_file(resolved_path)\n                    action = \"Updated\"\n                \n                with open(resolved_path, 'w', encoding='utf-8') as f:\n                    f.write(file_text)\n                \n                # Get preview\n                file_preview = self._get_file_preview(path)\n                return f\"Successfully {action} file: {path}\\n\\nPreview:\\n{file_preview}\"\n                \n            except Exception as e:\n                return f\"Error creating file: {str(e)}\"\n        \n        @tool\n        def list_directory(directory_path: str = \".\") -> str:\n            \"\"\"Get detailed listing of files and directories.\n            \n            Args:\n                directory_path: Path to the directory relative to workspace (default: workspace root)\n                \n            Returns:\n                Listing of files and directories with details\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(directory_path)\n                \n                if not os.path.isdir(resolved_path):\n                    return f\"Error: Not a directory: {directory_path}\"\n                \n                # List directory contents\n                entries = os.listdir(resolved_path)\n                result = f\"Contents of {directory_path}:\\n\"\n                \n                # Add directories first, then files\n                dirs = []\n                files = []\n                \n                for entry in entries:\n                    entry_path = os.path.join(resolved_path, entry)\n                    if os.path.isdir(entry_path):\n                        dirs.append((entry, \"directory\"))\n                    else:\n                        # Get file size\n                        size = os.path.getsize(entry_path)\n                        size_str = f\"{size} bytes\"\n                        if size > 1024:\n                            size_str = f\"{size/1024:.1f} KB\"\n                        if size > 1024*1024:\n                            size_str = f\"{size/(1024*1024):.1f} MB\"\n                        files.append((entry, \"file\", size_str))\n                \n                # Format and add to result\n                for name, type_ in sorted(dirs):\n                    result += f\"ðŸ“ {name}/ ({type_})\\n\"\n                for name, type_, size in sorted(files):\n                    result += f\"ðŸ“„ {name} ({type_}, {size})\\n\"\n                \n                if not dirs and not files:\n                    result += \"Directory is empty.\"\n                \n                return result\n                \n            except Exception as e:\n                return f\"Error listing directory: {str(e)}\"\n        \n        @tool\n        def move_file(source_path: str, destination_path: str) -> str:\n            \"\"\"Move or rename files and directories.\n            \n            Args:\n                source_path: Path to the source file/directory relative to workspace\n                destination_path: Path to the destination relative to workspace\n                \n            Returns:\n                Result of the operation\n            \"\"\"\n            try:\n                resolved_source = self.path_handler.resolve_path(source_path)\n                resolved_dest = self.path_handler.resolve_path(destination_path, must_exist=False)\n                \n                # Create backup for the source if it's a file\n                if os.path.isfile(resolved_source):\n                    self.backup_manager.backup_file(resolved_source)\n                \n                # Create backup for the destination if it exists and is a file\n                if os.path.isfile(resolved_dest) and os.path.exists(resolved_dest):\n                    self.backup_manager.backup_file(resolved_dest)\n                \n                # Create destination directory if it doesn't exist\n                dest_dir = os.path.dirname(resolved_dest)\n                os.makedirs(dest_dir, exist_ok=True)\n                \n                # Move/rename the file or directory\n                shutil.move(resolved_source, resolved_dest)\n                \n                source_type = \"directory\" if os.path.isdir(resolved_dest) else \"file\"\n                return f\"Successfully moved {source_type} from {source_path} to {destination_path}\"\n                \n            except Exception as e:\n                return f\"Error moving file: {str(e)}\"\n        \n        @tool\n        def search_files(search_pattern: str, directory_path: str = \".\") -> str:\n            \"\"\"Find files by name using case-insensitive substring matching.\n            \n            Args:\n                search_pattern: Pattern to search for in filenames\n                directory_path: Path to the directory to search in (default: workspace root)\n                \n            Returns:\n                List of matching files\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(directory_path)\n                \n                if not os.path.isdir(resolved_path):\n                    return f\"Error: Not a directory: {directory_path}\"\n                \n                # Search for matching files\n                matches = []\n                pattern = f\"*{search_pattern}*\"\n                \n                for root, dirs, files in os.walk(resolved_path):\n                    for name in files:\n                        if fnmatch.fnmatch(name.lower(), pattern.lower()):\n                            rel_path = os.path.relpath(os.path.join(root, name), self.workspace_folder)\n                            matches.append(rel_path)\n                \n                if not matches:\n                    return f\"No files matching '{search_pattern}' found in {directory_path}\"\n                \n                result = f\"Found {len(matches)} file(s) matching '{search_pattern}':\\n\"\n                for match in sorted(matches):\n                    result += f\"- {match}\\n\"\n                \n                return result\n                \n            except Exception as e:\n                return f\"Error searching files: {str(e)}\"\n        \n        @tool\n        def search_code(search_pattern: str, file_pattern: str = \"*\", directory_path: str = \".\") -> str:\n            \"\"\"Search for text/code patterns within file contents.\n            \n            Args:\n                search_pattern: Text pattern to search for in file contents\n                file_pattern: Filter for file types (e.g., \"*.py\" for Python files)\n                directory_path: Path to the directory to search in (default: workspace root)\n                \n            Returns:\n                Search results with file locations and line numbers\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(directory_path)\n                \n                if not os.path.isdir(resolved_path):\n                    return f\"Error: Not a directory: {directory_path}\"\n                \n                # Python-based search\n                matches = []\n                \n                for root, dirs, files in os.walk(resolved_path):\n                    for name in files:\n                        if fnmatch.fnmatch(name, file_pattern):\n                            file_path = os.path.join(root, name)\n                            try:\n                                with open(file_path, 'r', encoding='utf-8') as f:\n                                    for i, line in enumerate(f, 1):\n                                        if search_pattern in line:\n                                            rel_path = os.path.relpath(file_path, self.workspace_folder)\n                                            matches.append((rel_path, i, line.strip()))\n                            except:\n                                # Skip files that can't be read as text\n                                pass\n                \n                if not matches:\n                    return f\"No matches found for '{search_pattern}' in {directory_path}\"\n                \n                result = f\"Found {len(matches)} match(es) for '{search_pattern}':\\n\"\n                \n                for file_path, line_num, content in matches:\n                    result += f\"{file_path}:{line_num}: {content}\\n\"\n                \n                return result\n                \n            except Exception as e:\n                return f\"Error searching code: {str(e)}\"\n        \n        @tool\n        def generate_patch(path: str, old_content: Optional[str] = None, new_content: Optional[str] = None) -> str:\n            \"\"\"Generate a unified diff patch from old and new content.\n            \n            Args:\n                path: Path to the target file\n                old_content: Original content (if None, reads from file)\n                new_content: New content\n                \n            Returns:\n                A unified diff patch\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path)\n                \n                # If old_content not provided, read from file\n                if old_content is None:\n                    with open(resolved_path, 'r', encoding='utf-8') as f:\n                        old_content = f.read()\n                \n                # New content must be provided\n                if new_content is None:\n                    return \"Error: New content must be provided\"\n                \n                # Generate diff using difflib\n                old_lines = old_content.splitlines()\n                new_lines = new_content.splitlines()\n                \n                diff = difflib.unified_diff(\n                    old_lines, \n                    new_lines,\n                    lineterm='',\n                    n=3\n                )\n                \n                diff_text = '\\n'.join(diff)\n                return diff_text if diff_text else \"No differences found.\"\n                \n            except Exception as e:\n                return f\"Error generating patch: {str(e)}\"\n        \n        @tool\n        def find_code_structure(path: str, item_type: str = \"all\") -> str:\n            \"\"\"Analyze a file to find code structure elements like functions, classes, methods.\n            \n            Args:\n                path: Path to the file relative to workspace\n                item_type: Type of items to find (\"function\", \"class\", \"method\", \"all\")\n                \n            Returns:\n                Structured information about code elements with line ranges\n            \"\"\"\n            try:\n                resolved_path = self.path_handler.resolve_path(path)\n                \n                # Check file existence first\n                if not os.path.exists(resolved_path):\n                    return f\"Error: File not found: {path}\"\n                \n                # Check file size, handle empty files gracefully\n                if os.path.getsize(resolved_path) == 0:\n                    return f\"File {path} is empty.\"\n                \n                # Only supporting Python files for now\n                file_ext = os.path.splitext(resolved_path)[1].lower()\n                if file_ext != '.py':\n                    return f\"Note: Code structure analysis is currently only supported for Python (.py) files. File {path} has extension {file_ext}.\"\n                \n                # Read file content\n                with open(resolved_path, 'r', encoding='utf-8') as f:\n                    content = f.read()\n                \n                # Parse the Python code\n                try:\n                    tree = ast.parse(content)\n                except SyntaxError as e:\n                    return f\"Error: Could not parse {path} - syntax error at line {e.lineno}, column {e.offset}: {e.msg}\"\n                \n                # Helper function to extract line range for a node\n                def get_line_range(node):\n                    start_line = getattr(node, \"lineno\", 0)\n                    end_line = start_line\n                    \n                    # Try to find the last line of the node\n                    for child_node in ast.walk(node):\n                        if hasattr(child_node, \"lineno\"):\n                            end_line = max(end_line, child_node.lineno)\n                    \n                    return start_line, end_line\n                \n                # Find all matching nodes\n                result = f\"Code structure for {path}:\\n\\n\"\n                has_content = False\n                \n                # Functions\n                if item_type in [\"function\", \"all\"]:\n                    functions = [node for node in ast.walk(tree) if isinstance(node, ast.FunctionDef) and not hasattr(node, \"parent_class\")]\n                    if functions:\n                        has_content = True\n                        result += \"Functions:\\n\"\n                        for func in functions:\n                            start, end = get_line_range(func)\n                            result += f\"- {func.name} (lines {start}-{end})\\n\"\n                        result += \"\\n\"\n                \n                # Classes and methods\n                if item_type in [\"class\", \"method\", \"all\"]:\n                    classes = [node for node in ast.walk(tree) if isinstance(node, ast.ClassDef)]\n                    if classes:\n                        has_content = True\n                        result += \"Classes:\\n\"\n                        for cls in classes:\n                            cls_start, cls_end = get_line_range(cls)\n                            result += f\"- {cls.name} (lines {cls_start}-{cls_end})\\n\"\n                            \n                            if item_type in [\"method\", \"all\"]:\n                                methods = [node for node in ast.walk(cls) if isinstance(node, ast.FunctionDef)]\n                                for method in methods:\n                                    method.parent_class = cls.name  # Mark as a method\n                                    method_start, method_end = get_line_range(method)\n                                    result += f\"  - {method.name} (lines {method_start}-{method_end})\\n\"\n                        result += \"\\n\"\n                \n                # Check if we found anything\n                if not has_content:\n                    result += f\"No {item_type} items found in {path}.\"\n                \n                return result\n                \n            except Exception as e:\n                return f\"Error analyzing code structure: {str(e)}\"\n        \n        # Return all tools\n        return [\n            view_file,\n            edit_text,\n            insert_at_line,\n            remove_lines,\n            move_code_block,\n            undo_edit,\n            redo_edit,\n            create_file,\n            list_directory,\n            move_file,\n            search_files,\n            search_code,\n            generate_patch,\n            find_code_structure\n        ]\n"
              },
              "workspace_folder": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Workspace Folder",
                "dynamic": false,
                "info": "Base directory for all file operations. All paths will be relative to this folder.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "workspace_folder",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "/home/felipe/workspace/langflow"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "FileManipulation"
        },
        "dragging": false,
        "id": "FileManipulation-Z3xCV",
        "measured": {
          "height": 248,
          "width": 320
        },
        "position": {
          "x": 1232.999244219288,
          "y": 266.66753500534816
        },
        "selected": true,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "ShellSessionManager-lNmvb",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Manages persistent interactive shell sessions, allowing commands to be run asynchronously and output/signals to be managed. Warning: Executing arbitrary shell commands can be dangerous. Note: Interactive shells often produce expected diagnostic output on STDERR which can usually be ignored.",
            "display_name": "Shell Session Manager",
            "documentation": "",
            "edited": true,
            "field_order": [
              "working_directory",
              "default_shell",
              "sessions_directory"
            ],
            "frozen": false,
            "icon": "Terminal",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": false,
            "official": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tools",
                "hidden": false,
                "method": "build_toolkit",
                "name": "tools",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "# filename: shell_session_manager.py\r\nimport os\r\nimport platform\r\nimport subprocess\r\nimport threading\r\nimport time\r\nimport signal\r\nimport json\r\nimport psutil\r\nfrom queue import Queue, Empty\r\nfrom typing import Dict, Optional, Any, List\r\nfrom pathlib import Path\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.io import StrInput, Output\r\nfrom langchain_core.tools import tool\r\n\r\n\r\n# --- Signal Mapping ---\r\nSIGNAL_MAP = {\r\n    \"sigint\": signal.SIGINT,   # Interrupt (like Ctrl+C)\r\n    \"sigterm\": signal.SIGTERM, # Termination request (graceful shutdown)\r\n    \"sigkill\": signal.SIGKILL, # Force kill (like kill -9)\r\n}\r\n# Add Windows-specific signals if applicable\r\nif platform.system() == \"Windows\":\r\n    # SIGBREAK is often used for console interrupts on Windows\r\n    SIGNAL_MAP[\"sigbreak\"] = signal.SIGBREAK\r\n# --- End Signal Mapping ---\r\n\r\n\r\nclass ShellSessionManager(Component):\r\n    display_name = \"Shell Session Manager\"\r\n    description = (\r\n        \"Manages persistent interactive shell sessions, allowing commands \"\r\n        \"to be run asynchronously and output/signals to be managed. \"\r\n        \"Warning: Executing arbitrary shell commands can be dangerous. \"\r\n        \"Note: Interactive shells often produce expected diagnostic output \"\r\n        \"on STDERR which can usually be ignored.\"\r\n    )\r\n    icon = \"Terminal\"\r\n    name = \"ShellSessionManager\"\r\n\r\n    # File to store persistent session data\r\n    SESSIONS_FILE = os.path.join(os.path.expanduser(\"~\"), \".langflow_shell_sessions.json\")\r\n\r\n    inputs = [\r\n        StrInput(\r\n            name=\"working_directory\",\r\n            display_name=\"Working Directory\",\r\n            info=(\r\n                \"Optional base working directory for new shell sessions. \"\r\n                \"Absolute paths are strongly recommended. Relative paths are resolved \"\r\n                \"based on the Langflow process's CWD.\"\r\n            ),\r\n            required=False,\r\n            value=\"\",\r\n        ),\r\n        StrInput(\r\n            name=\"default_shell\",\r\n            display_name=\"Default Shell\",\r\n            info=(\r\n                \"Optional path to the default shell executable (e.g., 'bash', \"\r\n                \"'powershell', 'cmd.exe'). If not set, attempts auto-detection.\"\r\n            ),\r\n            required=False,\r\n            value=\"\",\r\n        ),\r\n        StrInput(\r\n            name=\"sessions_directory\",\r\n            display_name=\"Sessions Directory\",\r\n            info=(\r\n                \"Optional directory to store session data. \"\r\n                \"Defaults to ~/.langflow_shell_sessions/\"\r\n            ),\r\n            required=False,\r\n            value=\"\",\r\n        ),\r\n    ]\r\n\r\n    outputs = [\r\n        Output(name=\"tools\", display_name=\"Tools\", method=\"build_toolkit\"),\r\n    ]\r\n\r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.sessions: Dict[str, Dict[str, Any]] = {}\r\n        self._component_lock = threading.Lock()\r\n        self._session_output_files = {}\r\n        \r\n        # Create sessions directory if it doesn't exist\r\n        self.sessions_dir = self._get_sessions_directory()\r\n        os.makedirs(self.sessions_dir, exist_ok=True)\r\n        \r\n        # Load any existing sessions\r\n        self._load_sessions()\r\n\r\n    def _get_sessions_directory(self) -> str:\r\n        \"\"\"Get the directory for storing session data.\"\"\"\r\n        if hasattr(self, \"sessions_directory\") and self.sessions_directory:\r\n            directory = self.sessions_directory\r\n        else:\r\n            directory = os.path.join(os.path.expanduser(\"~\"), \".langflow_shell_sessions\")\r\n        return directory\r\n\r\n    def _get_session_file_path(self, session_id: str) -> str:\r\n        \"\"\"Get the path to a session's metadata file.\"\"\"\r\n        return os.path.join(self.sessions_dir, f\"{session_id}.json\")\r\n    \r\n    def _get_session_output_path(self, session_id: str) -> str:\r\n        \"\"\"Get the path to a session's output file.\"\"\"\r\n        return os.path.join(self.sessions_dir, f\"{session_id}.log\")\r\n\r\n    def _detect_shell(self) -> str:\r\n        system = platform.system()\r\n        if system == \"Windows\":\r\n            return os.environ.get(\"COMSPEC\", \"cmd.exe\")\r\n        return os.environ.get(\"SHELL\", \"/bin/sh\")\r\n\r\n    def _get_shell_command(self, shell_override: Optional[str] = None) -> list[str]:\r\n        shell_executable = shell_override or self.default_shell or self._detect_shell()\r\n        if \"cmd.exe\" in shell_executable.lower():\r\n            return [shell_executable, \"/K\", \"echo off\"]\r\n        elif \"powershell\" in shell_executable.lower():\r\n            return [shell_executable, \"-NoExit\", \"-Command\", \"-\"]\r\n        else:\r\n            return [shell_executable, \"-i\"]\r\n\r\n    def _read_stream(self, stream, queue: Queue, session_id: str, stream_name: str):\r\n        try:\r\n            # Open the output file for this session\r\n            output_path = self._get_session_output_path(session_id)\r\n            with open(output_path, \"a\", encoding=\"utf-8\") as output_file:\r\n                while stream and not stream.closed:\r\n                    line = stream.readline()\r\n                    if line:\r\n                        # Write to both queue and file\r\n                        queue.put(line)\r\n                        output_file.write(line)\r\n                        output_file.flush()\r\n                    else:\r\n                        break\r\n        except ValueError:\r\n             print(f\"Info: Stream {stream_name} for session {session_id} already closed.\")\r\n        except Exception as e:\r\n            print(f\"Error reading {stream_name} for session {session_id}: {type(e).__name__}: {e}\")\r\n        finally:\r\n            queue.put(None)\r\n\r\n    def _save_session(self, session_id: str, session_data: dict):\r\n        \"\"\"Save session metadata to disk.\"\"\"\r\n        try:\r\n            # Filter out non-serializable objects\r\n            serializable_data = {\r\n                \"session_id\": session_id,\r\n                \"shell_type\": session_data.get(\"shell_type\", \"\"),\r\n                \"working_dir\": session_data.get(\"working_dir\", \"\"),\r\n                \"pid\": session_data[\"process\"].pid if \"process\" in session_data else None,\r\n                \"start_time\": time.time(),\r\n            }\r\n            \r\n            # Save to a session-specific file\r\n            session_file = self._get_session_file_path(session_id)\r\n            with open(session_file, \"w\") as f:\r\n                json.dump(serializable_data, f)\r\n        except Exception as e:\r\n            print(f\"Error saving session {session_id} to disk: {e}\")\r\n\r\n    def _delete_session_file(self, session_id: str):\r\n        \"\"\"Delete session metadata file from disk.\"\"\"\r\n        try:\r\n            session_file = self._get_session_file_path(session_id)\r\n            if os.path.exists(session_file):\r\n                os.remove(session_file)\r\n                \r\n            # Also try to delete output file if it exists\r\n            output_file = self._get_session_output_path(session_id)\r\n            if os.path.exists(output_file):\r\n                os.remove(output_file)\r\n        except Exception as e:\r\n            print(f\"Error deleting session file for {session_id}: {e}\")\r\n\r\n    def _load_sessions(self):\r\n        \"\"\"Load session data from disk and verify which sessions are still running.\"\"\"\r\n        try:\r\n            # Look for all session files in the sessions directory\r\n            session_files = [f for f in os.listdir(self.sessions_dir) if f.endswith('.json')]\r\n            \r\n            recovered = 0\r\n            for session_file in session_files:\r\n                try:\r\n                    session_id = session_file.replace('.json', '')\r\n                    file_path = os.path.join(self.sessions_dir, session_file)\r\n                    \r\n                    with open(file_path, 'r') as f:\r\n                        session_data = json.load(f)\r\n                    \r\n                    # Check if the process is still running\r\n                    pid = session_data.get('pid')\r\n                    if pid and self._is_process_running(pid):\r\n                        # Process is still running, recover the session\r\n                        self._recover_session(session_id, session_data)\r\n                        recovered += 1\r\n                    else:\r\n                        # Process is not running, clean up the session files\r\n                        self._delete_session_file(session_id)\r\n                except Exception as e:\r\n                    print(f\"Error loading session from {session_file}: {e}\")\r\n            \r\n            if recovered > 0:\r\n                print(f\"Recovered {recovered} active shell sessions\")\r\n        except Exception as e:\r\n            print(f\"Error loading sessions: {e}\")\r\n\r\n    def _is_process_running(self, pid: int) -> bool:\r\n        \"\"\"Check if a process with the given PID is still running.\"\"\"\r\n        try:\r\n            # Check if process exists and is not a zombie/defunct\r\n            process = psutil.Process(pid)\r\n            return process.is_running() and process.status() != psutil.STATUS_ZOMBIE\r\n        except (psutil.NoSuchProcess, psutil.AccessDenied, psutil.ZombieProcess):\r\n            return False\r\n        except Exception as e:\r\n            print(f\"Error checking process {pid}: {e}\")\r\n            return False\r\n\r\n    def _recover_session(self, session_id: str, session_data: dict):\r\n        \"\"\"Recover a running session by reconnecting to its process.\"\"\"\r\n        try:\r\n            pid = session_data.get('pid')\r\n            if not pid:\r\n                print(f\"Cannot recover session {session_id}: No PID found\")\r\n                return\r\n                \r\n            # Create new queues for stdout/stderr\r\n            stdout_q, stderr_q = Queue(), Queue()\r\n            \r\n            # Create minimal session data that allows interaction\r\n            shell_type = session_data.get('shell_type', self._detect_shell())\r\n            working_dir = session_data.get('working_dir', os.getcwd())\r\n            \r\n            # Get the process object\r\n            process = psutil.Process(pid)\r\n            \r\n            print(f\"Recovering session {session_id} (PID: {pid}, Shell: {shell_type})\")\r\n            \r\n            # Create a new session entry with minimal information needed\r\n            with self._component_lock:\r\n                self.sessions[session_id] = {\r\n                    \"process\": process,\r\n                    \"stdout_q\": stdout_q,\r\n                    \"stderr_q\": stderr_q,\r\n                    \"stdout_thread\": None,  # We don't have access to the original streams\r\n                    \"stderr_thread\": None,\r\n                    \"shell_type\": shell_type,\r\n                    \"working_dir\": working_dir,\r\n                    \"lock\": threading.Lock(),\r\n                    \"recovered\": True,  # Mark as recovered\r\n                }\r\n        except Exception as e:\r\n            print(f\"Error recovering session {session_id}: {e}\")\r\n            # Clean up the session files since recovery failed\r\n            self._delete_session_file(session_id)\r\n\r\n    def _read_output_file(self, session_id: str, max_lines: int = 100) -> str:\r\n        \"\"\"Read recent output from the session's output file.\"\"\"\r\n        output_path = self._get_session_output_path(session_id)\r\n        try:\r\n            if not os.path.exists(output_path):\r\n                return f\"No output file found for session {session_id}\"\r\n                \r\n            # Read the last max_lines from the output file\r\n            with open(output_path, 'r', encoding='utf-8') as f:\r\n                # Read all lines and get the last max_lines\r\n                lines = f.readlines()\r\n                if not lines:\r\n                    return f\"No output available for session {session_id}\"\r\n                    \r\n                recent_lines = lines[-max_lines:] if max_lines > 0 else lines\r\n                return \"\".join(recent_lines)\r\n        except Exception as e:\r\n            return f\"Error reading output for session {session_id}: {e}\"\r\n\r\n    def build_toolkit(self) -> List[Tool]:\r\n        \"\"\"Builds and returns the shell session management tools.\"\"\"\r\n\r\n        @tool\r\n        def start_shell_session(\r\n            session_name: str = \"\", shell_override: Optional[str] = None, cwd: Optional[str] = None\r\n        ) -> str:\r\n            \"\"\"Starts a new interactive shell session.\r\n\r\n            Args:\r\n                session_name (str): Custom name for the session (must not contain spaces). If empty, a name will be generated.\r\n                shell_override (Optional[str]): Path to a specific shell executable.\r\n                cwd (Optional[str]): Working directory. Absolute paths recommended.\r\n                                     Relative paths resolved based on component/process CWD.\r\n\r\n            Returns:\r\n                str: Success message with session ID or an error message.\r\n            \"\"\"\r\n            # Generate session ID based on input or create a default name\r\n            if not session_name:\r\n                session_name = f\"shell_{int(time.time())}\"\r\n            elif \" \" in session_name:\r\n                return f\"Error: Session name '{session_name}' cannot contain spaces. Please provide a valid name.\"\r\n            \r\n            # First, check if we need to cleanup any stale sessions with this name\r\n            with self._component_lock:\r\n                if session_name in self.sessions:\r\n                    # Check if the session is actually still running\r\n                    process = self.sessions[session_name][\"process\"]\r\n                    \r\n                    # For recovered sessions, check differently\r\n                    if self.sessions[session_name].get(\"recovered\", False):\r\n                        is_running = self._is_process_running(process.pid)\r\n                    else:\r\n                        is_running = process.poll() is None\r\n                        \r\n                    if not is_running:\r\n                        # Process has terminated, clean up and reuse the name\r\n                        print(f\"Found stale session with name '{session_name}', cleaning up before reuse\")\r\n                        self._cleanup_session(session_name)\r\n                    else:\r\n                        # Session is still running\r\n                        return f\"Error: Session '{session_name}' already exists and is still running. Please choose a different name.\"\r\n            \r\n            print(f\"Starting new session with name: {session_name}\")\r\n                        \r\n            component_base_cwd = self.working_directory or None\r\n            effective_base_cwd = os.getcwd()\r\n            if component_base_cwd and os.path.isabs(component_base_cwd):\r\n                effective_base_cwd = component_base_cwd\r\n\r\n            resolved_cwd = cwd\r\n            if resolved_cwd:\r\n                if not os.path.isabs(resolved_cwd):\r\n                    resolved_cwd = os.path.abspath(os.path.join(effective_base_cwd, resolved_cwd))\r\n            elif component_base_cwd:\r\n                if os.path.isabs(component_base_cwd):\r\n                    resolved_cwd = component_base_cwd\r\n                else:\r\n                    resolved_cwd = os.path.abspath(os.path.join(effective_base_cwd, component_base_cwd))\r\n            else:\r\n                resolved_cwd = None\r\n\r\n            if resolved_cwd and not os.path.isdir(resolved_cwd):\r\n                 return f\"Error: Resolved working directory '{resolved_cwd}' not found or not a directory.\"\r\n\r\n            try:\r\n                shell_cmd = self._get_shell_command(shell_override)\r\n                shell_type = shell_cmd[0]\r\n                print(f\"Starting session {session_name}: Shell={shell_cmd}, CWD={resolved_cwd or 'Default'}\")\r\n\r\n                process = subprocess.Popen(\r\n                    shell_cmd, stdin=subprocess.PIPE, stdout=subprocess.PIPE, stderr=subprocess.PIPE,\r\n                    text=True, encoding='utf-8', errors='replace', cwd=resolved_cwd,\r\n                    bufsize=1, universal_newlines=True, shell=False,\r\n                    start_new_session=(platform.system() != \"Windows\")\r\n                )\r\n                stdout_q, stderr_q = Queue(), Queue()\r\n                stdout_thread = threading.Thread(target=self._read_stream, args=(process.stdout, stdout_q, session_name, \"stdout\"), daemon=True)\r\n                stderr_thread = threading.Thread(target=self._read_stream, args=(process.stderr, stderr_q, session_name, \"stderr\"), daemon=True)\r\n                stdout_thread.start(); stderr_thread.start()\r\n\r\n                with self._component_lock:\r\n                    self.sessions[session_name] = {\r\n                        \"process\": process, \"stdout_q\": stdout_q, \"stderr_q\": stderr_q,\r\n                        \"stdout_thread\": stdout_thread, \"stderr_thread\": stderr_thread,\r\n                        \"shell_type\": shell_type, \"working_dir\": resolved_cwd or os.getcwd(),\r\n                        \"lock\": threading.Lock(),\r\n                    }\r\n                    \r\n                # Save session data to disk for persistence\r\n                self._save_session(session_name, self.sessions[session_name])\r\n                \r\n                return f\"Session started with ID: {session_name}\"\r\n            except Exception as e:\r\n                print(f\"Error starting session {session_name}: {e}\")\r\n                return f\"Error starting shell session: {str(e)}\"\r\n\r\n        @tool\r\n        def run_command(session_id: str, command: str) -> str:\r\n            \"\"\"Sends a command to a running shell session asynchronously.\r\n\r\n            Args:\r\n                session_id (str): The ID of the target session.\r\n                command (str): The command string to execute.\r\n\r\n            Returns:\r\n                str: Confirmation message or an error.\r\n            \"\"\"\r\n            with self._component_lock:\r\n                session = self.sessions.get(session_id)\r\n            if not session: return f\"Error: Session ID '{session_id}' not found.\"\r\n\r\n            process = session[\"process\"]\r\n            \r\n            # For recovered sessions, check process status differently\r\n            if session.get(\"recovered\", False):\r\n                if not self._is_process_running(process.pid):\r\n                    with self._component_lock:\r\n                        if session_id in self.sessions:\r\n                            print(f\"Session {session_id} found terminated before running command, cleaning up.\")\r\n                            self._cleanup_session(session_id)\r\n                    return f\"Error: Session '{session_id}' appears to have terminated.\"\r\n            else:\r\n                # Standard case\r\n                if process.poll() is not None:\r\n                    with self._component_lock:\r\n                        if session_id in self.sessions:\r\n                            print(f\"Session {session_id} found terminated before running command, cleaning up.\")\r\n                            self._cleanup_session(session_id)\r\n                    return f\"Error: Session '{session_id}' appears to have terminated.\"\r\n\r\n            try:\r\n                with session[\"lock\"]:\r\n                    # For recovered sessions, we need to reopen stdin\r\n                    if session.get(\"recovered\", False):\r\n                        try:\r\n                            # Use psutil to get process information\r\n                            proc = psutil.Process(process.pid)\r\n                            \r\n                            # Try to send the command using OS-specific methods\r\n                            if platform.system() == \"Windows\":\r\n                                # On Windows, this is more complicated and may not work reliably\r\n                                return f\"Warning: Cannot send commands to recovered sessions on Windows. Please start a new session.\"\r\n                            else:\r\n                                # On Unix-like systems, we can try using the proc filesystem\r\n                                newline = \"\\n\"\r\n                                if not command.endswith(newline): command += newline\r\n                                \r\n                                # Write to the log file\r\n                                output_path = self._get_session_output_path(session_id)\r\n                                with open(output_path, \"a\", encoding=\"utf-8\") as output_file:\r\n                                    output_file.write(f\"COMMAND: {command}\")\r\n                                    output_file.flush()\r\n                                \r\n                                # Need to use os.write to a pipe or similar\r\n                                return f\"Warning: Sending command to recovered session {session_id} may not work. Command recorded in log.\"\r\n                        except Exception as e:\r\n                            print(f\"Error sending command to recovered session {session_id}: {e}\")\r\n                            return f\"Error sending command to recovered session {session_id}: {str(e)}\"\r\n                    \r\n                    # Normal case - session we created\r\n                    newline = \"\\r\\n\" if session[\"shell_type\"].lower().endswith(\"cmd.exe\") else \"\\n\"\r\n                    if not command.endswith(newline): command += newline\r\n                    if not process.stdin or process.stdin.closed:\r\n                         print(f\"Error: Stdin for session {session_id} is closed. Cleaning up.\")\r\n                         with self._component_lock:\r\n                              if session_id in self.sessions: self._cleanup_session(session_id)\r\n                         return f\"Error sending command: Stdin for session {session_id} is closed.\"\r\n\r\n                    process.stdin.write(command)\r\n                    process.stdin.flush()\r\n                return f\"Command sent to session {session_id}.\"\r\n            except (IOError, OSError, BrokenPipeError) as e:\r\n                print(f\"Error writing to session {session_id}: {e}\")\r\n                with self._component_lock:\r\n                    if session_id in self.sessions: self._cleanup_session(session_id)\r\n                return f\"Error sending command to session {session_id}: {str(e)}. Session may have terminated.\"\r\n            except Exception as e:\r\n                 print(f\"Unexpected error sending command to {session_id}: {e}\")\r\n                 return f\"Error sending command to session {session_id}: {str(e)}\"\r\n\r\n        @tool\r\n        def get_session_output(session_id: str, read_all: bool = True, max_lines: int = 100) -> str:\r\n            \"\"\"Retrieves available stdout/stderr from a session since the last call.\r\n\r\n            Args:\r\n                session_id (str): The ID of the target session.\r\n                read_all (bool): If True, reads all currently buffered output. Default True.\r\n                max_lines (int): For recovered sessions, max number of lines to read from log file.\r\n\r\n            Returns:\r\n                str: Formatted output, status message, or error message.\r\n            \"\"\"\r\n            with self._component_lock:\r\n                 session = self.sessions.get(session_id)\r\n            if not session: return f\"Error: Session ID '{session_id}' not found.\"\r\n\r\n            # For recovered sessions, read from the log file\r\n            if session.get(\"recovered\", False):\r\n                output = self._read_output_file(session_id, max_lines)\r\n                \r\n                # Check if the process is still running\r\n                if not self._is_process_running(session[\"process\"].pid):\r\n                    with self._component_lock:\r\n                        if session_id in self.sessions:\r\n                            self._cleanup_session(session_id)\r\n                    return output + f\"\\n(Session '{session_id}' has terminated.)\"\r\n                return output\r\n\r\n            # Standard case - read from queues\r\n            stdout_lines, stderr_lines = [], []\r\n            with session[\"lock\"]:\r\n                 stdout_q, stderr_q = session[\"stdout_q\"], session[\"stderr_q\"]\r\n                 try:\r\n                    while True:\r\n                        line = stdout_q.get_nowait()\r\n                        if line is None:\r\n                             if session[\"stdout_thread\"].is_alive(): session[\"stdout_thread\"].join(timeout=0.5)\r\n                             break\r\n                        stdout_lines.append(line)\r\n                        if not read_all: break\r\n                 except Empty: pass\r\n                 try:\r\n                    while True:\r\n                        line = stderr_q.get_nowait()\r\n                        if line is None:\r\n                            if session[\"stderr_thread\"].is_alive(): session[\"stderr_thread\"].join(timeout=0.5)\r\n                            break\r\n                        stderr_lines.append(line)\r\n                        if not read_all: break\r\n                 except Empty: pass\r\n\r\n            output = \"\"\r\n            if stdout_lines: output += \"STDOUT:\\n\" + \"\".join(stdout_lines)\r\n            if stderr_lines: output += \"STDERR:\\n\" + \"\".join(stderr_lines)\r\n\r\n            if not output:\r\n                process = session[\"process\"]\r\n                if process.poll() is not None:\r\n                    final_stdout, final_stderr = [], []\r\n                    with session[\"lock\"]:\r\n                         try:\r\n                              while True: line = stdout_q.get_nowait(); final_stdout.append(line) if line is not None else Ellipsis\r\n                         except Empty: pass\r\n                         try:\r\n                              while True: line = stderr_q.get_nowait(); final_stderr.append(line) if line is not None else Ellipsis\r\n                         except Empty: pass\r\n                    if final_stdout: output += \"STDOUT (final):\\n\" + \"\".join(final_stdout)\r\n                    if final_stderr: output += \"STDERR (final):\\n\" + \"\".join(final_stderr)\r\n\r\n                    rc = process.returncode\r\n                    msg = f\"(Session '{session_id}' terminated with exit code: {rc})\"\r\n                    return (output.strip() + f\"\\n{msg}\") if output else f\"Session '{session_id}' terminated with exit code: {rc}. No final output.\"\r\n\r\n                else:\r\n                     return f\"Session '{session_id}' has no new output available.\"\r\n            return output.strip()\r\n\r\n        @tool\r\n        def list_shell_sessions() -> str:\r\n            \"\"\"Lists active shell sessions, cleaning up terminated ones found during check.\r\n\r\n            Returns:\r\n                str: Formatted list of active sessions or 'No active sessions.'\r\n            \"\"\"\r\n            print(f\"Listing sessions, current session dict has {len(self.sessions)} entries\")\r\n            \r\n            # Scan the sessions directory first for any sessions we may have missed\r\n            try:\r\n                session_files = [f for f in os.listdir(self.sessions_dir) if f.endswith('.json')]\r\n                for session_file in session_files:\r\n                    session_id = session_file.replace('.json', '')\r\n                    # If we don't have this session in memory, try to load it\r\n                    if session_id not in self.sessions:\r\n                        try:\r\n                            file_path = os.path.join(self.sessions_dir, session_file)\r\n                            with open(file_path, 'r') as f:\r\n                                session_data = json.load(f)\r\n                            \r\n                            # Check if the process is still running\r\n                            pid = session_data.get('pid')\r\n                            if pid and self._is_process_running(pid):\r\n                                # Process is still running, recover the session\r\n                                self._recover_session(session_id, session_data)\r\n                            else:\r\n                                # Process is not running, clean up the session files\r\n                                self._delete_session_file(session_id)\r\n                        except Exception as e:\r\n                            print(f\"Error checking session file {session_file}: {e}\")\r\n            except Exception as e:\r\n                print(f\"Error scanning sessions directory: {e}\")\r\n            \r\n            active_sessions_info = []\r\n            terminated_sessions = []\r\n            \r\n            # First pass: collect status of all sessions\r\n            for session_id, session in self.sessions.items():\r\n                print(f\"Checking session {session_id}\")\r\n                try:\r\n                    process = session[\"process\"]\r\n                    \r\n                    # Check if process is running\r\n                    is_running = False\r\n                    if session.get(\"recovered\", False):\r\n                        is_running = self._is_process_running(process.pid)\r\n                    else:\r\n                        is_running = process.poll() is None\r\n                    \r\n                    print(f\"Session {session_id} running status: {is_running}\")\r\n                    \r\n                    if is_running:\r\n                        # Process is still running\r\n                        active_sessions_info.append(f\"  - ID: {session_id}, Shell: {session['shell_type']}, CWD: {session['working_dir']}\")\r\n                    else:\r\n                        # Process has terminated, mark for cleanup\r\n                        terminated_sessions.append(session_id)\r\n                        print(f\"Session {session_id} found terminated during listing\")\r\n                except Exception as e:\r\n                    print(f\"Error checking session {session_id}: {e}\")\r\n                    # If we can't check the session, assume it's terminated\r\n                    terminated_sessions.append(session_id)\r\n            \r\n            # Second pass: clean up terminated sessions\r\n            for session_id in terminated_sessions:\r\n                try:\r\n                    with self._component_lock:\r\n                        if session_id in self.sessions:\r\n                            print(f\"Cleaning up terminated session {session_id}\")\r\n                            self._cleanup_session(session_id)\r\n                except Exception as e:\r\n                    print(f\"Error cleaning up session {session_id}: {e}\")\r\n            \r\n            # Return appropriate message based on active session count\r\n            if active_sessions_info:\r\n                return \"Active Shell Sessions:\\n\" + \"\\n\".join(active_sessions_info)\r\n            else:\r\n                return \"No active sessions.\" if not terminated_sessions else \"No active sessions found (all terminated sessions cleaned up).\"\r\n\r\n        @tool\r\n        def send_signal_to_session(session_id: str, signal_name: str = \"SIGINT\") -> str:\r\n            \"\"\"Sends a signal (e.g., SIGINT for Ctrl+C, SIGKILL for kill -9)\r\n               to the process running in the specified session.\r\n\r\n            Args:\r\n                session_id (str): The ID of the target session.\r\n                signal_name (str): The name of the signal to send. Common values:\r\n                                   'SIGINT' (default, like Ctrl+C),\r\n                                   'SIGTERM' (graceful shutdown request),\r\n                                   'SIGKILL' (forceful kill). Case-insensitive.\r\n                                   On Windows, 'SIGBREAK' may also be useful.\r\n\r\n            Returns:\r\n                str: Confirmation message or an error.\r\n            \"\"\"\r\n            normalized_signal_name = signal_name.lower()\r\n            signal_to_send = SIGNAL_MAP.get(normalized_signal_name)\r\n\r\n            if signal_to_send is None:\r\n                supported_keys = list(SIGNAL_MAP.keys())\r\n                if platform.system() != \"Windows\" and \"sigbreak\" in supported_keys:\r\n                    supported_keys.remove(\"sigbreak\")\r\n                supported = \", \".join(supported_keys)\r\n                return f\"Error: Invalid signal name '{signal_name}'. Supported (case-insensitive): {supported}\"\r\n\r\n            with self._component_lock:\r\n                session = self.sessions.get(session_id)\r\n            if not session:\r\n                return f\"Error: Session ID '{session_id}' not found.\"\r\n\r\n            process = session[\"process\"]\r\n            with session[\"lock\"]:\r\n                # Check if process is running\r\n                is_running = False\r\n                if session.get(\"recovered\", False):\r\n                    is_running = self._is_process_running(process.pid)\r\n                    if not is_running:\r\n                        return f\"Error: Process in session '{session_id}' already terminated. Cannot send signal.\"\r\n                else:\r\n                    poll_result = process.poll()\r\n                    if poll_result is not None:\r\n                        return f\"Error: Process in session '{session_id}' already terminated (exit code: {poll_result}). Cannot send signal.\"\r\n                    is_running = True\r\n\r\n                try:\r\n                    pid_info = f\"PID {process.pid}\" if hasattr(process, 'pid') else \"PID unknown\"\r\n                    print(f\"Sending signal {normalized_signal_name} ({signal_to_send}) to process {pid_info} in session {session_id}\")\r\n                    \r\n                    # For recovered sessions, use psutil\r\n                    if session.get(\"recovered\", False):\r\n                        try:\r\n                            psutil.Process(process.pid).send_signal(signal_to_send)\r\n                        except psutil.NoSuchProcess:\r\n                            return f\"Error: Process {process.pid} in session '{session_id}' no longer exists.\"\r\n                    else:\r\n                        process.send_signal(signal_to_send)\r\n                        \r\n                    if signal_to_send == signal.SIGKILL:\r\n                         time.sleep(0.05)\r\n                         # Check status appropriately based on session type\r\n                         if session.get(\"recovered\", False):\r\n                             final_status = not self._is_process_running(process.pid)\r\n                         else:\r\n                             final_poll = process.poll()\r\n                             final_status = final_poll is not None\r\n                             \r\n                         status = \"terminated\" if final_status else \"signal sent\"\r\n                         return f\"Sent sigkill to process in session {session_id}. Process status: {status}.\"\r\n                    else:\r\n                         return f\"Sent {normalized_signal_name} to process in session {session_id}.\"\r\n                except Exception as e:\r\n                    print(f\"Error sending signal {normalized_signal_name} to session {session_id}: {type(e).__name__}: {e}\")\r\n                    \r\n                    # Check current status\r\n                    current_status = None\r\n                    if session.get(\"recovered\", False):\r\n                        current_status = not self._is_process_running(process.pid)\r\n                    else:\r\n                        current_poll = process.poll()\r\n                        current_status = current_poll is not None\r\n                        \r\n                    if current_status:\r\n                         return f\"Error sending signal {normalized_signal_name}: Process in session {session_id} terminated concurrently. Original error: {str(e)}\"\r\n                    else:\r\n                         return f\"Error sending signal {normalized_signal_name} to session {session_id}: {str(e)}\"\r\n\r\n        @tool\r\n        def close_shell_session(session_id: str) -> str:\r\n            \"\"\"Closes a specific shell session and cleans up its resources.\r\n\r\n            Args:\r\n                session_id (str): The ID of the session to close.\r\n\r\n            Returns:\r\n                str: Confirmation message or an error.\r\n            \"\"\"\r\n            with self._component_lock:\r\n                if session_id not in self.sessions:\r\n                    return f\"Error: Session ID '{session_id}' not found.\"\r\n                result = self._cleanup_session(session_id)\r\n            return result\r\n\r\n        return [\r\n            start_shell_session,\r\n            run_command,\r\n            get_session_output,\r\n            list_shell_sessions,\r\n            send_signal_to_session,\r\n            close_shell_session,\r\n        ]\r\n\r\n    def _cleanup_session(self, session_id: str) -> str:\r\n        \"\"\"Internal helper to clean up a session. Must be called holding _component_lock.\"\"\"\r\n        session = self.sessions.pop(session_id, None)\r\n        if not session:\r\n            print(f\"Warning: Attempted cleanup of non-existent session {session_id}.\")\r\n            return f\"Info: Session '{session_id}' already cleaned up or never existed.\"\r\n\r\n        # Delete session file first\r\n        self._delete_session_file(session_id)\r\n\r\n        process = session[\"process\"]\r\n        shell_type = session[\"shell_type\"]\r\n        \r\n        # For recovered sessions, we don't have direct access to threads\r\n        if session.get(\"recovered\", False):\r\n            pid_info = f\"PID {process.pid}\" if hasattr(process, 'pid') else \"PID unknown\"\r\n            print(f\"Cleaning up recovered session {session_id} (Shell: {shell_type}, {pid_info})\")\r\n            \r\n            try:\r\n                # Check if the process is still running\r\n                if self._is_process_running(process.pid):\r\n                    try:\r\n                        # Try to terminate the process\r\n                        process.terminate() \r\n                        time.sleep(0.2)\r\n                        \r\n                        # If still running, try to kill\r\n                        if self._is_process_running(process.pid):\r\n                            process.kill()\r\n                            time.sleep(0.2)\r\n                    except (psutil.NoSuchProcess, psutil.AccessDenied) as e:\r\n                        print(f\"Error terminating recovered process: {e}\")\r\n                \r\n                return f\"Session {session_id} closed.\"\r\n            except Exception as e:\r\n                print(f\"Error closing recovered session {session_id}: {e}\")\r\n                return f\"Error closing session {session_id}: {str(e)}\"\r\n        \r\n        # Standard case - session we created\r\n        stdout_thread = session[\"stdout_thread\"]\r\n        stderr_thread = session[\"stderr_thread\"]\r\n        pid_info = f\"PID {process.pid}\" if hasattr(process, 'pid') else \"PID unknown\"\r\n        print(f\"Cleaning up session {session_id} (Shell: {shell_type}, {pid_info})\")\r\n\r\n        try:\r\n            # Check if the process is still running before attempting interaction\r\n            if process.poll() is None:\r\n                try:\r\n                    # Attempt graceful exit first\r\n                    stdin_closed = getattr(process.stdin, 'closed', True)\r\n                    if not stdin_closed:\r\n                        try:\r\n                            cmd = \"exit\\r\\n\" if shell_type.lower().endswith(\"cmd.exe\") else \"exit\\n\"\r\n                            process.stdin.write(cmd); process.stdin.flush(); process.stdin.close()\r\n                        except (BrokenPipeError, OSError, ValueError):\r\n                            print(f\"Session {session_id}: Info - Stdin likely closed before sending exit.\")\r\n                    # Wait briefly for graceful exit\r\n                    process.wait(timeout=0.5)\r\n\r\n                except subprocess.TimeoutExpired:\r\n                    print(f\"Session {session_id}: Graceful exit timed out, terminating.\")\r\n                    try:\r\n                        process.terminate() # Send SIGTERM\r\n                        process.wait(timeout=1) # Wait for termination\r\n                    except subprocess.TimeoutExpired:\r\n                        print(f\"Session {session_id}: Termination timed out, killing.\")\r\n                        try:\r\n                            process.kill() # Send SIGKILL\r\n                            process.wait(timeout=1) # Wait for kill\r\n                        except Exception as kill_wait_e:\r\n                            print(f\"Session {session_id}: Exc during kill wait: {kill_wait_e}\")\r\n                    except Exception as term_wait_e:\r\n                         # Error during terminate/wait (e.g., process already dead)\r\n                         print(f\"Session {session_id}: Error during term/wait: {term_wait_e}. Attempting kill.\")\r\n                         # Check if still alive before kill - CORRECTED BLOCK\r\n                         if process.poll() is None:\r\n                              try:\r\n                                   process.kill()\r\n                                   process.wait(timeout=0.5)\r\n                              except Exception as final_kill_e:\r\n                                   print(f\"Session {session_id}: Exception during final kill/wait after term error: {final_kill_e}\")\r\n\r\n                except (BrokenPipeError, OSError, ValueError) as e:\r\n                     # Handle other potential errors during interaction (e.g., process died during wait)\r\n                    print(f\"Session {session_id}: Error during graceful exit attempt: {e}\")\r\n                    # Ensure kill if it's still running after the error - CORRECTED BLOCK\r\n                    if process.poll() is None:\r\n                        print(f\"Session {session_id}: Killing process due to previous error.\")\r\n                        try:\r\n                            process.kill()\r\n                            process.wait(timeout=0.5)\r\n                        except Exception as kill_wait_e:\r\n                             print(f\"Session {session_id}: Exception during final kill wait after IO error: {kill_wait_e}\")\r\n\r\n            # Process is confirmed or presumed terminated at this point\r\n            return_code = process.poll() # Get final exit code if possible\r\n            print(f\"Session {session_id} process ended (Final code: {return_code}).\")\r\n\r\n            # Close streams safely\r\n            for stream in [process.stdin, process.stdout, process.stderr]:\r\n                 if stream and not stream.closed:\r\n                    try: stream.close()\r\n                    except (OSError, ValueError): pass # Ignore errors on already closed streams\r\n\r\n            # Wait for reader threads\r\n            for thread, name in [(stdout_thread, \"stdout\"), (stderr_thread, \"stderr\")]:\r\n                if thread and thread.is_alive():\r\n                    thread.join(timeout=0.5) # Wait a bit longer for threads\r\n                    if thread.is_alive():\r\n                        print(f\"Warning: {name} thread for session {session_id} did not join cleanly.\")\r\n\r\n            return f\"Session {session_id} closed.\"\r\n\r\n        except Exception as e:\r\n            # Catch-all for unexpected errors during cleanup\r\n            print(f\"Critical Error during cleanup of session {session_id}: {type(e).__name__}: {e}\")\r\n            return f\"Error cleaning up session {session_id}: {str(e)}\"\r\n\r\n    def __del__(self):\r\n        \"\"\"Attempt to clean up any remaining sessions when the component instance is deleted.\"\"\"\r\n        print(\"ShellSessionManager deleting, cleaning up sessions...\")\r\n        with self._component_lock:\r\n             session_ids = list(self.sessions.keys()) # Copy keys as cleanup modifies dict\r\n             for session_id in session_ids:\r\n                try:\r\n                    # Call cleanup directly, it handles removing from self.sessions\r\n                    self._cleanup_session(session_id)\r\n                except Exception as e:\r\n                    # Log error specific to the __del__ context\r\n                    print(f\"Error cleaning up session {session_id} during component deletion: {e}\")\r\n        print(\"ShellSessionManager cleanup finished.\")"
              },
              "default_shell": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Default Shell",
                "dynamic": false,
                "info": "Optional path to the default shell executable (e.g., 'bash', 'powershell', 'cmd.exe'). If not set, attempts auto-detection.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "default_shell",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "bash"
              },
              "sessions_directory": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Sessions Directory",
                "dynamic": false,
                "info": "Optional directory to store session data. Defaults to ~/.langflow_shell_sessions/",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "sessions_directory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": ""
              },
              "working_directory": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Working Directory",
                "dynamic": false,
                "info": "Optional base working directory for new shell sessions. Absolute paths are strongly recommended. Relative paths are resolved based on the Langflow process's CWD.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "working_directory",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "/home/felipe/workspace/langflow"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "ShellSessionManager"
        },
        "dragging": false,
        "id": "ShellSessionManager-lNmvb",
        "measured": {
          "height": 512,
          "width": 320
        },
        "position": {
          "x": 1241.6721756290872,
          "y": 583.2592312797453
        },
        "selected": false,
        "type": "genericNode"
      },
      {
        "data": {
          "id": "note-b0CBv",
          "node": {
            "description": "Add Langflow Repo Path >>",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-b0CBv",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 1030.1894705906475,
          "y": 829.5878058749249
        },
        "resizing": false,
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-vOcFs",
          "node": {
            "description": "Add Langflow Repo Path >>",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-vOcFs",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 1011.3689526436426,
          "y": 410.22355126585086
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "note-EyUSx",
          "node": {
            "description": "Add Langflow Repo Path >>",
            "display_name": "",
            "documentation": "",
            "template": {
              "backgroundColor": "transparent"
            }
          },
          "type": "note"
        },
        "dragging": false,
        "id": "note-EyUSx",
        "measured": {
          "height": 324,
          "width": 324
        },
        "position": {
          "x": 1027.6965694001972,
          "y": 1288.73587622448
        },
        "selected": false,
        "type": "noteNode"
      },
      {
        "data": {
          "id": "CustomComponent-tDs9a",
          "node": {
            "base_classes": [
              "Tool"
            ],
            "beta": false,
            "conditional_paths": [],
            "custom_fields": {},
            "description": "Advanced Git operations system for repository management with commit, branch, and clone capabilities",
            "display_name": "Git Operations",
            "documentation": "",
            "edited": true,
            "field_order": [
              "workspace_folder",
              "create_if_missing"
            ],
            "frozen": false,
            "icon": "Git",
            "legacy": false,
            "lf_version": "1.4.2",
            "metadata": {},
            "minimized": false,
            "output_types": [],
            "outputs": [
              {
                "allows_loop": false,
                "cache": true,
                "display_name": "Tools",
                "hidden": false,
                "method": "build_toolkit",
                "name": "tools",
                "options": null,
                "required_inputs": null,
                "selected": "Tool",
                "tool_mode": true,
                "types": [
                  "Tool"
                ],
                "value": "__UNDEFINED__"
              }
            ],
            "pinned": false,
            "template": {
              "_type": "Component",
              "code": {
                "advanced": true,
                "dynamic": true,
                "fileTypes": [],
                "file_path": "",
                "info": "",
                "list": false,
                "load_from_db": false,
                "multiline": true,
                "name": "code",
                "password": false,
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "type": "code",
                "value": "from langchain_core.tools import tool\r\nimport os\r\nimport subprocess\r\nfrom typing import List, Optional\r\n\r\nfrom langflow.custom import Component\r\nfrom langflow.field_typing import Tool\r\nfrom langflow.io import StrInput, Output, BoolInput\r\n\r\n\r\nclass GitOperations(Component):\r\n    display_name = \"Git Operations\"\r\n    description = \"Advanced Git operations system for repository management with commit, branch, and clone capabilities\"\r\n    icon = \"Git\"\r\n    name = \"GitOperations\"\r\n    \r\n    inputs = [\r\n        StrInput(\r\n            name=\"workspace_folder\",\r\n            display_name=\"Workspace Folder\",\r\n            info=\"Base working directory for all Git operations. All paths will be relative to this folder.\",\r\n            required=True,\r\n        ),\r\n        BoolInput(\r\n            name=\"create_if_missing\",\r\n            display_name=\"Create Workspace If Missing\",\r\n            info=\"Create the workspace folder if it doesn't exist\",\r\n            value=True,\r\n        ),\r\n    ]\r\n    \r\n    outputs = [\r\n        Output(name=\"tools\", display_name=\"Tools\", method=\"build_toolkit\"),\r\n    ]\r\n    \r\n    def __init__(self, *args, **kwargs):\r\n        super().__init__(*args, **kwargs)\r\n        self.command_history = []  # Track executed Git commands\r\n    \r\n    def _resolve_path(self, relative_path: str) -> str:\r\n        \"\"\"Resolve a relative path to absolute path within workspace.\"\"\"\r\n        if os.path.isabs(relative_path):\r\n            raise ValueError(f\"Path must be relative to workspace: {relative_path}\")\r\n        full_path = os.path.normpath(os.path.join(self.workspace_folder, relative_path))\r\n        if not full_path.startswith(os.path.abspath(self.workspace_folder)):\r\n            raise ValueError(f\"Path must be within workspace: {relative_path}\")\r\n        return full_path\r\n    \r\n    def _run_git_command(self, command: List[str], repo_path: str = \"\") -> str:\r\n        try:\r\n            work_dir = self.workspace_folder\r\n            if repo_path:\r\n                work_dir = self._resolve_path(repo_path)\r\n            if self.create_if_missing and not os.path.exists(self.workspace_folder):\r\n                os.makedirs(self.workspace_folder, exist_ok=True)\r\n            full_command = [\"git\"] + command\r\n            self.command_history.append(f\"git {' '.join(command)}\")\r\n            process = subprocess.run(\r\n                full_command,\r\n                cwd=work_dir,\r\n                capture_output=True,\r\n                text=True,\r\n                check=False\r\n            )\r\n            if process.returncode != 0:\r\n                error_message = process.stderr.strip()\r\n                return f\"Error executing git command:\\n{error_message}\"\r\n            output = process.stdout.strip()\r\n            if output:\r\n                return output\r\n            return \"Command executed successfully.\"\r\n        except Exception as e:\r\n            return f\"Error executing git command: {str(e)}\"\r\n    \r\n    def _is_git_repo(self, repo_path: str = \"\") -> bool:\r\n        try:\r\n            work_dir = self.workspace_folder\r\n            if repo_path:\r\n                work_dir = self._resolve_path(repo_path)\r\n            result = subprocess.run(\r\n                [\"git\", \"rev-parse\", \"--is-inside-work-tree\"],\r\n                cwd=work_dir,\r\n                capture_output=True,\r\n                text=True,\r\n                check=False\r\n            )\r\n            return result.returncode == 0\r\n        except Exception:\r\n            return False\r\n    \r\n    def build_toolkit(self) -> Tool:\r\n        @tool\r\n        def git_init(directory_path: str = \".\") -> str:\r\n            \"\"\"Initialize a new Git repository.\r\n            \r\n            Args:\r\n                directory_path: Path to directory relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            repo_path = self._resolve_path(directory_path)\r\n            if not os.path.exists(repo_path):\r\n                os.makedirs(repo_path, exist_ok=True)\r\n            if self._is_git_repo(directory_path):\r\n                return f\"Directory is already a Git repository: {directory_path}\"\r\n            return self._run_git_command([\"init\"], directory_path)\r\n        \r\n        @tool\r\n        def git_status(repo_path: str = \".\") -> str:\r\n            \"\"\"Show the working tree status.\r\n            \r\n            Args:\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Git status output\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            return self._run_git_command([\"status\"], repo_path)\r\n        \r\n        @tool\r\n        def git_add(paths: List[str] = None, all_files: bool = False, repo_path: str = \".\") -> str:\r\n            \"\"\"Add file contents to the index.\r\n            \r\n            Args:\r\n                paths: List of file paths to add (relative to repo)\r\n                all_files: If True, add all files (equivalent to git add .)\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            if all_files:\r\n                return self._run_git_command([\"add\", \".\"], repo_path)\r\n            elif paths:\r\n                return self._run_git_command([\"add\"] + paths, repo_path)\r\n            else:\r\n                return \"Error: Either specify paths or set all_files=True\"\r\n        \r\n        @tool\r\n        def git_commit(message: str, repo_path: str = \".\") -> str:\r\n            \"\"\"Record changes to the repository.\r\n            \r\n            Args:\r\n                message: Commit message\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            user_email = subprocess.run(\r\n                [\"git\", \"config\", \"user.email\"],\r\n                cwd=self._resolve_path(repo_path),\r\n                capture_output=True,\r\n                text=True,\r\n                check=False\r\n            )\r\n            user_name = subprocess.run(\r\n                [\"git\", \"config\", \"user.name\"],\r\n                cwd=self._resolve_path(repo_path),\r\n                capture_output=True,\r\n                text=True,\r\n                check=False\r\n            )\r\n            if not user_email.stdout.strip():\r\n                self._run_git_command([\"config\", \"user.email\", \"agent@example.com\"], repo_path)\r\n            if not user_name.stdout.strip():\r\n                self._run_git_command([\"config\", \"user.name\", \"AI Agent\"], repo_path)\r\n            return self._run_git_command([\"commit\", \"-m\", message], repo_path)\r\n        \r\n        @tool\r\n        def git_clone(repository_url: str, directory_path: Optional[str] = None, depth: Optional[int] = None) -> str:\r\n            \"\"\"Clone a repository into a new directory.\r\n            \r\n            Args:\r\n                repository_url: URL of the repository to clone\r\n                directory_path: Directory to clone into (relative to workspace)\r\n                depth: Create a shallow clone with the specified depth\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            command = [\"clone\"]\r\n            if depth is not None:\r\n                command.extend([\"--depth\", str(depth)])\r\n            command.append(repository_url)\r\n            if directory_path:\r\n                target_path = self._resolve_path(directory_path)\r\n                command.append(directory_path)\r\n            return self._run_git_command(command)\r\n        \r\n        @tool\r\n        def git_pull(repo_path: str = \".\", remote: str = \"origin\", branch: Optional[str] = None) -> str:\r\n            \"\"\"Fetch from and integrate with another repository or a local branch.\r\n            \r\n            Args:\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n                remote: Remote repository name\r\n                branch: Branch name to pull (default: current branch)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"pull\", remote]\r\n            if branch:\r\n                command.append(branch)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_push(repo_path: str = \".\", remote: str = \"origin\", branch: Optional[str] = None) -> str:\r\n            \"\"\"Update remote refs along with associated objects.\r\n            \r\n            Args:\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n                remote: Remote repository name\r\n                branch: Branch name to push (default: current branch)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"push\", remote]\r\n            if branch:\r\n                command.append(branch)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_branch(new_branch: Optional[str] = None, list_branches: bool = False, repo_path: str = \".\") -> str:\r\n            \"\"\"List, create, or delete branches.\r\n            \r\n            Args:\r\n                new_branch: Create a new branch with this name\r\n                list_branches: List all branches if True\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            if list_branches:\r\n                return self._run_git_command([\"branch\"], repo_path)\r\n            elif new_branch:\r\n                return self._run_git_command([\"branch\", new_branch], repo_path)\r\n            else:\r\n                return \"Error: Either specify a new branch name or set list_branches=True\"\r\n        \r\n        @tool\r\n        def git_checkout(branch_name: str, repo_path: str = \".\", create_branch: bool = False) -> str:\r\n            \"\"\"Switch branches or restore working tree files.\r\n            \r\n            Args:\r\n                branch_name: Branch to checkout\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n                create_branch: Create branch if it doesn't exist (-b flag)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"checkout\"]\r\n            if create_branch:\r\n                command.append(\"-b\")\r\n            command.append(branch_name)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_merge(source_branch: str, repo_path: str = \".\", commit_message: Optional[str] = None) -> str:\r\n            \"\"\"Merge a source branch into the current branch.\r\n            \r\n            Args:\r\n                source_branch: The name of the branch whose changes are to be merged into the current branch\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n                commit_message: If a merge commit is created (not a fast-forward), use this message\r\n            \r\n            Returns:\r\n                Result of the operation, including information about conflicts if they occur\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"merge\"]\r\n            if commit_message:\r\n                command.extend([\"-m\", commit_message])\r\n            command.append(source_branch)\r\n            result = self._run_git_command(command, repo_path)\r\n            if \"CONFLICT\" in result or \"Automatic merge failed\" in result:\r\n                return f\"Merge conflict detected:\\n{result}\\nResolve conflicts manually and commit the result.\"\r\n            return result\r\n        \r\n        @tool\r\n        def git_log(max_count: Optional[int] = None, repo_path: str = \".\", pretty_format: str = \"oneline\") -> str:\r\n            \"\"\"Show commit logs.\r\n            \r\n            Args:\r\n                max_count: Limit the number of commits to show\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n                pretty_format: Format for displaying commits (oneline, short, medium, full, etc.)\r\n            \r\n            Returns:\r\n                Git log output\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"log\", f\"--pretty={pretty_format}\"]\r\n            if max_count is not None:\r\n                command.extend([\"-n\", str(max_count)])\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_diff(files: List[str] = None, staged: bool = False, repo_path: str = \".\") -> str:\r\n            \"\"\"Show changes between commits, commit and working tree, etc.\r\n            \r\n            Args:\r\n                files: List of files to show diff for\r\n                staged: Show staged changes only\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Git diff output\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            command = [\"diff\"]\r\n            if staged:\r\n                command.append(\"--staged\")\r\n            if files:\r\n                command.extend(files)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_remote(operation: str = \"show\", remote_name: Optional[str] = None, \r\n                       remote_url: Optional[str] = None, repo_path: str = \".\") -> str:\r\n            \"\"\"Manage set of tracked repositories.\r\n            \r\n            Args:\r\n                operation: Remote operation (show, add, remove)\r\n                remote_name: Name of the remote\r\n                remote_url: URL for the remote (needed for 'add' operation)\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            if operation == \"show\":\r\n                command = [\"remote\", \"-v\"]\r\n            elif operation == \"add\":\r\n                if not remote_name or not remote_url:\r\n                    return \"Error: Both remote_name and remote_url are required for 'add' operation\"\r\n                command = [\"remote\", \"add\", remote_name, remote_url]\r\n            elif operation == \"remove\":\r\n                if not remote_name:\r\n                    return \"Error: remote_name is required for 'remove' operation\"\r\n                command = [\"remote\", \"remove\", remote_name]\r\n            else:\r\n                return f\"Error: Unsupported operation: {operation}\"\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_reset(file_paths: List[str] = None, mode: str = \"mixed\", \r\n                      commit: str = \"HEAD\", repo_path: str = \".\") -> str:\r\n            \"\"\"Reset current HEAD to the specified state.\r\n            \r\n            Args:\r\n                file_paths: List of file paths to reset\r\n                mode: Reset mode (soft, mixed, hard)\r\n                commit: Commit to reset to (default: HEAD)\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            if not self._is_git_repo(repo_path):\r\n                return f\"Error: Not a Git repository: {repo_path}\"\r\n            valid_modes = [\"soft\", \"mixed\", \"hard\"]\r\n            if mode not in valid_modes:\r\n                return f\"Error: Invalid mode '{mode}'. Must be one of {valid_modes}\"\r\n            command = [\"reset\"]\r\n            if mode != \"mixed\":\r\n                command.append(f\"--{mode}\")\r\n            command.append(commit)\r\n            if file_paths:\r\n                command.extend([\"--\"] + file_paths)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_config(key: str, value: Optional[str] = None, \r\n                       global_config: bool = False, repo_path: str = \".\") -> str:\r\n            \"\"\"Get and set repository or global options.\r\n            \r\n            Args:\r\n                key: Configuration key\r\n                value: Configuration value (if setting)\r\n                global_config: Use global config if True\r\n                repo_path: Path to repository relative to workspace (default: workspace root)\r\n            \r\n            Returns:\r\n                Result of the operation\r\n            \"\"\"\r\n\r\n            command = [\"config\"]\r\n            if global_config:\r\n                command.append(\"--global\")\r\n            command.append(key)\r\n            if value is not None:\r\n                command.append(value)\r\n            return self._run_git_command(command, repo_path)\r\n        \r\n        @tool\r\n        def git_command_history() -> str:\r\n            \"\"\"View the history of executed Git commands.\r\n            \r\n            Returns:\r\n                List of previously executed Git commands\r\n            \"\"\"\r\n\r\n            if not self.command_history:\r\n                return \"No Git commands have been executed yet.\"\r\n            history = \"\\n\".join([f\"{i+1}. {cmd}\" for i, cmd in enumerate(self.command_history)])\r\n            return f\"Git Command History:\\n{history}\"\r\n        \r\n        return [\r\n            git_init,\r\n            git_status,\r\n            git_add,\r\n            git_commit,\r\n            git_clone,\r\n            git_pull,\r\n            git_push,\r\n            git_branch,\r\n            git_checkout,\r\n            git_merge,\r\n            git_log,\r\n            git_diff,\r\n            git_remote,\r\n            git_reset,\r\n            git_config,\r\n            git_command_history\r\n        ]\r\n"
              },
              "create_if_missing": {
                "_input_type": "BoolInput",
                "advanced": false,
                "display_name": "Create Workspace If Missing",
                "dynamic": false,
                "info": "Create the workspace folder if it doesn't exist",
                "list": false,
                "list_add_label": "Add More",
                "name": "create_if_missing",
                "placeholder": "",
                "required": false,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "bool",
                "value": true
              },
              "workspace_folder": {
                "_input_type": "StrInput",
                "advanced": false,
                "display_name": "Workspace Folder",
                "dynamic": false,
                "info": "Base working directory for all Git operations. All paths will be relative to this folder.",
                "list": false,
                "list_add_label": "Add More",
                "load_from_db": false,
                "name": "workspace_folder",
                "placeholder": "",
                "required": true,
                "show": true,
                "title_case": false,
                "tool_mode": false,
                "trace_as_metadata": true,
                "type": "str",
                "value": "/home/felipe/workspace/langflow"
              }
            },
            "tool_mode": false
          },
          "showNode": true,
          "type": "GitOperations"
        },
        "dragging": false,
        "id": "CustomComponent-tDs9a",
        "measured": {
          "height": 307,
          "width": 320
        },
        "position": {
          "x": 1237.2556674744521,
          "y": 1155.6701093190493
        },
        "selected": false,
        "type": "genericNode"
      }
    ],
    "viewport": {
      "x": -163.4637075445646,
      "y": -99.0134554496641,
      "zoom": 0.526011317601265
    }
  },
  "description": "A simple but powerful starter agent.",
  "endpoint_name": null,
  "id": "5e0d9225-59e7-49f0-9522-41bc5d217108",
  "is_component": false,
  "last_tested_version": "1.4.2",
  "name": "Component Maker Agent",
  "tags": [
    "assistants",
    "agents"
  ]
}